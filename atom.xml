<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[王仙客的博客]]></title>
  <link href="http://Hydra2050.github.io/atom.xml" rel="self"/>
  <link href="http://Hydra2050.github.io/"/>
  <updated>2015-02-08T15:58:12+08:00</updated>
  <id>http://Hydra2050.github.io/</id>
  <author>
    <name><![CDATA[王仙客]]></name>
    <email><![CDATA[wh2050@sina.cn]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何创建和使用私有cocoapods repo]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/08/ru-he-chuang-jian-he-shi-yong-si-you-cocoapods-repo/"/>
    <updated>2015-02-08T15:22:36+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/08/ru-he-chuang-jian-he-shi-yong-si-you-cocoapods-repo</id>
    <content type="html"><![CDATA[<h2>安装cocoapods</h2>

<pre><code>gem update --system
gem sources -l
gem install cocoapods
pod setup
</code></pre>

<h2>创建私有cocoapods repo</h2>

<h3>第一步，创建私有Spec Repo</h3>

<p>在服务器创建repo裸仓库：</p>

<pre><code>mkdir REPO_NAME.git
cd REPO_NAME.git
git init --bare
</code></pre>

<h3>第二步，将私有pod repo添加到本地</h3>

<pre><code>pod repo list
pod repo add REPO_NAME SOURCE_URL
</code></pre>

<h3>第三步，检测pod repo是否正确</h3>

<pre><code>pod repo lint REPO_NAME
</code></pre>

<h2>为私有pod添加新的Spec</h2>

<h3>第一步，创建podspec文件</h3>

<pre><code>pod spec create SPEC_NAME
</code></pre>

<h3>第二步，修改Spec文件</h3>

<h3>第三步，检测Spec文件是否正确</h3>

<pre><code>pod spec lint SPEC_NAME
</code></pre>

<h3>第四步，上传Spec文件至私有pod repo</h3>

<pre><code>pod repo push REPO_NAME SPEC_NAME.podspec
</code></pre>

<p>因为我使用的时<code>ssh</code>URL获取，会产生<code>warning</code>：</p>

<pre><code>    - WARN  | [source] Git SSH URLs will NOT work for people behind firewalls configured to only allow HTTP, therefore HTTPS is preferred.
</code></pre>

<p>可以忽略这个警告：</p>

<pre><code>pod repo push --allow-warnings REPO_NAME SPEC_NAME.podspec
</code></pre>

<h2>spec lint 技巧</h2>

<p>在执行<code>pod spec line xxx</code>的时候出错，但提示往往比较简单，可以添加参数<code>--no-clean</code>：</p>

<pre><code>pod spec lint --no-clean xxx
</code></pre>

<p>执行完成后，根据提示的路径，打开lint生成的工程文件，编译查看出错的原因。</p>

<p>一般路径为：<code>/private/tmp/CocoaPods/Lint/Pods/Pods.xcodeproj</code>。</p>

<p>参考链接：<a href="http://guides.cocoapods.org/making/private-cocoapods.html">http://guides.cocoapods.org/making/private-cocoapods.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何提高pod install执行速度]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/08/ru-he-ti-gao-pod-installzhi-xing-su-du/"/>
    <updated>2015-02-08T14:05:04+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/08/ru-he-ti-gao-pod-installzhi-xing-su-du</id>
    <content type="html"><![CDATA[<p>应用集成了cocoapods一段时间，发现每次执行<code>pod insgtall</code>命令都会比较慢，有时要等十多分钟甚至更久，严重影响工作效率和开发的心情。</p>

<h2><code>pod install</code>执行慢的原因</h2>

<p>Cocopods的<code>pod install</code>命令一般分两步：</p>

<ol>
<li>执行<code>pod repo update</code>，更新本地的repo Spec文件（<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>）</li>
<li>根据spec的配置，获取源文件，一般是通过git clone的方式从github上下载第三方库</li>
</ol>


<p>由于<code>GWF</code>的存在，经常存在github无法访问的情况；有时可以访问，速度也比较慢。人生苦短！！</p>

<p>可以针对这两方面进行提高<code>pod install</code>执行速度。</p>

<h2>减少pod repo update的次数</h2>

<p>执行<code>pod repo update</code>是必要的，保证每次安装的时候，能够获取最新的Spec文件。但不必每次都执行，建议每天执行一次。在执行<code>pod install</code>的时候添加参数，不再执行<code>pod repo update</code>：</p>

<pre><code>pod install --no-repo-update
</code></pre>

<h2>使用本地的git mirror解决下载慢的问题</h2>

<p>解决了repo更新的问题，仍然存在一系列问题：</p>

<ul>
<li>将源文件克隆到本地速度缓慢</li>
<li>一旦被托管在github上的第三方库被删除掉，我们将再也无法获取到第三方库</li>
<li>如果访问外网的网络暂时性的中断，无法执行<code>pod install</code>，影响正常开发</li>
</ul>


<p>为了解决以上问题，在公共服务器上搭建了一个GitMirror，为每一个使用到的第三方库创建一个mirror仓库。以后每次执行install的时候，实际都是从本地服务器下载，速度就会有明显的提升。</p>

<h3>修改本地spec配置</h3>

<p>第一步要将第三库的源文件下载地址修改为本地服务器。写了一个脚本<code>moveToGitMirror.py</code>自动完成本地spec配置修改。执行命令如下：</p>

<pre><code>cd ~/.cocoapods/repos/master/
python moveToGitMirror.py
</code></pre>

<p>这个脚本的功能很简单，遍历当前目录下的文件，查找后缀名为.spec.json的文件，查找到source路径，然后修改为镜像地址。</p>

<p>这里需要注意的是，一旦修改，将完全依赖镜像的服务器。可以替换成一个指定的域名，而不是一个固定的ip地址。这样通过修改本地<code>hosts</code>文件，实现source路径的整体切换。</p>

<h3>为一个第三方库创建git mirror</h3>

<p>如果项目中需要一个第三方库，以<code>Masonry</code>为例。</p>

<pre><code>ssh root@xx.xx.xx.xx
cd GitRepoMirror/
git clone --mirror https://github.com/Masonry/Masonry.git
</code></pre>

<h3>设置免密码远程访问</h3>

<p>完成以上的操作，执行<code>pod install</code>，会发现下载一个第三方库都需要我们输入一次密码。what？？？太烦了！</p>

<p>为了实现免密码远程访问，我们需要把本机的rsa公钥放入远程服务器的<code>authorized_keys</code>文件下。如果本机没有生产过rsa密钥，执行以下命令：</p>

<pre><code>ssh-keygen -t rsa -C "xxx.com"
</code></pre>

<h2>下一步</h2>

<p>下一步，可以创建一个属于自己的私有pod repo了，以后再介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImagePickerController cause idleTimerDisabled setting problem]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/01/10/uiimagepickercontroller-cause-idletimerdisabled-setting-not-working/"/>
    <updated>2015-01-10T10:48:27+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/01/10/uiimagepickercontroller-cause-idletimerdisabled-setting-not-working</id>
    <content type="html"><![CDATA[<p>前一段时间，遇到了一个奇怪的问题：在程序里设置了<code>idleTimerDisabled</code>为<code>YES</code>，但是还是有用户反馈，程序会自动锁屏。测试也曾反馈，曾经遇到过这个问题，但一直未找到重现方法。在Stackoverflow看到，与UIImagePickerController的使用有关。</p>

<h2>重现</h2>

<p>设置<code>idleTimerDisabled</code>为<code>YES</code>，创建UIImagePickerController，设置sourceType为<code>UIImagePickerControllerSourceTypeCamera</code>，然后弹出拍照页面。拍照页面关闭后，等待自动锁屏的出现。</p>

<h2>分析</h2>

<p>设置断点:</p>

<pre><code>-[UIApplication setIdleTimerDisabled:]
</code></pre>

<p><img src="http://Hydra2050.github.io/images/20150110_1.png" alt="idleTimer breakpoint" /></p>

<p>运行后会发现，在UIImagePickerController弹出的时候，进入一次断点。使用LLDB命令(因为我用的是arm64的机器，所以寄存器为x，如果是armv7，为r)：</p>

<pre><code>po $x0
&lt;UIApplication: 0x156e008e0&gt;

p (SEL)$x1
(SEL) $1 = "setIdleTimerDisabled:"

po $x2
1
</code></pre>

<p>在弹出UIImagePickerController的时候，系统会自动将<code>idleTimerDisabled</code>设置为<code>YES</code>。</p>

<p>继续运行，关闭UIImagePickerController，由于这只的animation为<code>YES</code>，会进入两次断点。两次的参数相同，都为<code>nil</code>。</p>

<pre><code>po $x2
nil
</code></pre>

<p>这就会将<code>idleTimerDisabled</code>设置为<code>NO</code>，导致之前设置的值被修改。</p>

<h2>解决</h2>

<p>目前想到的解决方法，在UIImagePickerController消失后，重新设置idleTimerDisabled为需要的值。</p>

<pre><code>#pragma mark - UIImagePickerControllerDelegate

- (void)imagePickerController:(UIImagePickerController *)picker         didFinishPickingMediaWithInfo:(NSDictionary *)info
{
    [self dismissViewControllerAnimated:YES completion:^{
    [self performSelector:@selector(resetIdleTimerDisabled) withObject:nil          afterDelay:1.0];
     }];
}

- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker
{
  [self dismissViewControllerAnimated:YES completion:^{
  [self performSelector:@selector(resetIdleTimerDisabled) withObject:nil        afterDelay:1.0];
   }];
}
</code></pre>

<p>参考：</p>

<p><a href="http://stackoverflow.com/questions/23391564/ios-idletimerdisabled-yes-works-only-until-imagepicker-was-used">http://stackoverflow.com/questions/23391564/ios-idletimerdisabled-yes-works-only-until-imagepicker-was-used</a></p>

<p><a href="http://www.objc.io/issue-19/">http://www.objc.io/issue-19/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac book升级Yosemite异常的解决方法]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/19/mac-booksheng-ji-yosemiteyi-chang-de-jie-jue-fang-fa/"/>
    <updated>2014-10-19T11:11:55+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/19/mac-booksheng-ji-yosemiteyi-chang-de-jie-jue-fang-fa</id>
    <content type="html"><![CDATA[<p>前天苹果更新新版桌面操作系统OS X Yosemite，版本号为OS X 10.10。兴匆匆地升级我的Mac book，等了好久，更新重启之后出现了下面这个画面：</p>

<p><img src="http://Hydra2050.github.io/images/20141019.jpg" alt="OooppP" /></p>

<p>解决方法很简单：</p>

<ul>
<li>第一步：长按关机键，然后重新启动，同时一直按住<code>alt</code>键</li>
<li>第二步：在出现的界面选择无线网络，并成功连接</li>
<li>第三部：按<code>command</code> ＋ <code>r</code>，进入网络恢复模式</li>
</ul>


<p>经过N久的等待，终于又恢复正常了，开始体验新的OS X —— Yosemite！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge–Level 3]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-3/"/>
    <updated>2014-10-19T10:35:11+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-3</id>
    <content type="html"><![CDATA[<p>Level3地址：<a href="http://www.pythonchallenge.com/pc/def/equality.html">http://www.pythonchallenge.com/pc/def/equality.html</a></p>

<h2>分析</h2>

<p>提示文字：</p>

<pre><code>One small letter, surrounded by EXACTLY three big bodyguards on each of its sides.
</code></pre>

<p>根据上一次的经验，查看网页的源码，标题为<code>re</code>，看来和正则表达式有关系了。</p>

<p>网页源码里仍然有一段被注释的字符串，看来就要在这一串中找出两边大写中间小写字母的内容了。</p>

<h2>解决</h2>

<pre><code>text = ‘’’
       …
       ‘’’
import re
pattern = re.compile(r'[A-Z]{3}([a-z])[A-Z]{3}')
result = re.findall(pattern,text)
print(‘’.join(result))
</code></pre>

<p>发现打印出来很多结果，哪里出了问题？</p>

<p>再仔细看提示语：<code>EXACTLY</code>，必须是有且只有三个大写字母。</p>

<p>修改正则表达式：</p>

<pre><code>pattern = re.compile(r'[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]')
</code></pre>

<p>输出：</p>

<pre><code>linkedlist
</code></pre>

<h2>其他解决方法</h2>

<p><a href="http://www.pythonchallenge.com/pcc/def/linkedlist.php">http://www.pythonchallenge.com/pcc/def/linkedlist.php</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge–Level 2]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-2/"/>
    <updated>2014-10-19T09:15:54+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-2</id>
    <content type="html"><![CDATA[<h2>分析</h2>

<p>Level2的地址：<a href="http://www.pythonchallenge.com/pc/def/ocr.html">http://www.pythonchallenge.com/pc/def/ocr.html</a></p>

<p>文字提示<code>MAYBE they are in the page source</code></p>

<p>查看网页的源码，发现注释的部分：</p>

<pre><code>find rare characters in the mess below:
</code></pre>

<p>需要从那段内容中找出稀少的字符。</p>

<h2>解决</h2>

<pre><code>text = ‘’’
      …
       ‘’’
result = {}
for x in text:
    result[x] = result.get(x,0) + 1
print(result)
</code></pre>

<p>输出：</p>

<pre><code>{'(': 6154, ')': 6186, '*': 6034, '+': 6066, 'l': 1, 'i': 1, ' ': 4880, '!': 6079, '#': 6115, '$': 6046, '%': 6104, '&amp;': 6043, 'e': 1, 'y': 1, '{': 6046, '}': 6105, 'q': 1, 't': 1, 'u': 1, 'a': 1, '\n': 1221, '@': 6157, '[': 6108, ']': 6152, '^': 6030, '_': 6112}
</code></pre>

<p>发现最少的都是个数为1的字母，这样稍加改变：</p>

<pre><code>result = []
for x in text:
    if x.isalpha():
        result.append(x)
print(''.join(result))
</code></pre>

<p>输出：</p>

<pre><code>equality
</code></pre>

<h2>其他的解决方法</h2>

<p>按照惯例，查看解决方法：<a href="http://www.pythonchallenge.com/pcc/def/ocr.html">http://www.pythonchallenge.com/pcc/def/ocr.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge--Level 1]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/11/the-python-challenge-level-1/"/>
    <updated>2014-10-11T21:46:08+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/11/the-python-challenge-level-1</id>
    <content type="html"><![CDATA[<p>Level 1的地址：<a href="http://www.pythonchallenge.com/pc/def/map.html">http://www.pythonchallenge.com/pc/def/map.html</a></p>

<h2>分析</h2>

<p>网页的标题为<code>What about making trans?</code>，然后再看图片：</p>

<pre><code>K -&gt; M
O -&gt; Q
E -&gt; G
</code></pre>

<p>应该是一个类似凯撒密码的字母移位，每个字母向后移动两位，而要处理的就是下面那段文字。</p>

<h2>解决</h2>

<p>代码如下：</p>

<pre><code>'''
Level 1
'''
text = '''
g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr   gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle    qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.
'''
trans = ''
for x in text:
    trans += chr((ord(x) - ord('a') + 2)%26 + ord('a')) if x.isalpha() else x
print(trans)
</code></pre>

<p>输出结果：</p>

<pre><code>i hope you didnt translate it by hand. thats what computers are for. doing it in
by hand is inefficient and that's why this text is so long. using string.maketrans() 
is recommended. now apply on the url.
</code></pre>

<p>根据转化后的信息，处理url中的map进行同样的转换，获得新的url：<a href="http://www.pythonchallenge.com/pc/def/ocr.html">http://www.pythonchallenge.com/pc/def/ocr.html</a>，顺利进入下一关。</p>

<h2>str.maketrans()</h2>

<p>等等，仔细看转换后的信息，推荐使用string.maketrans()方法。</p>

<p>查找<a href="https://docs.python.org/3/">python3在线文档</a>，发现在python3.4后有所变化。</p>

<p>代码如下：</p>

<pre><code>''
use str.maketrans()
'''

import string

text = '''
g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr   gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle    qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.
'''

dlist = string.ascii_lowercase
table = str.maketrans(dlist,dlist[2:] + dlist[:2])
print(text.translate(table))
</code></pre>

<p>首先，使用str.maketrans()方法生成一个映射表，从[A－Z]映射为[C-A]，打印<code>table</code>：</p>

<pre><code>{97: 99, 98: 100, 99: 101, 100: 102, 101: 103, 102: 104, 103: 105, 104: 106, 105: 107, 106: 108, 107: 109, 108: 110, 109: 111, 110: 112, 111: 113, 112: 114, 113: 115, 114: 116, 115: 117, 116: 118, 117: 119, 118: 120, 119: 121, 120: 122, 121: 97, 122: 98}
</code></pre>

<p>然后，调用translate()方法，将映射表作为参数。最终获取想要的结果。</p>

<p><code>str.maketrans()</code>的第一个和第二个参数长度必须相同，转换的时候一一对应；如果有第三个参数，将会转换为<code>None</code>。</p>

<pre><code>mm = 'abcdefg'
tb1 = str.maketrans('abcd','1234')
tb2 = str.maketrans('abcd','1234','ef')
print(mm.translate(tb1))
print(mm.translate(tb2))
</code></pre>

<p>输出结果：</p>

<pre><code>1234efg
1234g
</code></pre>

<h2>其他的解决方法</h2>

<p>进入下一个Level的页面，有一条tips，将当前url中的<code>pc</code>改为<code>pcc</code>就可以查看前一个Level的解决方法了。</p>

<p><a href="http://www.pythonchallenge.com/pcc/def/ocr.html">http://www.pythonchallenge.com/pcc/def/ocr.html</a></p>

<p>参考资料：</p>

<p><a href="https://docs.python.org/3/">Python documentation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge--Level 0]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/10/the-python-challenge-level-0/"/>
    <updated>2014-10-10T22:51:40+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/10/the-python-challenge-level-0</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>最近空余时间，开始学习python，发现一个很有意思的网站：<a href="http://www.pythonchallenge.com/">pythonchallenge</a>。目前有33个挑战的级别，打算写一个系列的博客，记录下来学习的过程。那就从零开始吧！</p>

<h2>Level 0</h2>

<p>Level 0的地址：<a href="http://www.pythonchallenge.com/pc/def/0.html">http://www.pythonchallenge.com/pc/def/0.html</a></p>

<p>一张图片，上面写着2的38次方</p>

<pre><code>Hint: try to change the URL address.
</code></pre>

<p>使用python求2的38次方的值：</p>

<pre><code>2**38
</code></pre>

<p>或者：</p>

<pre><code>import math
pow(2,38)
</code></pre>

<p>或者：</p>

<pre><code>1 &lt;&lt; 38
</code></pre>

<p>得到结果：274877906944</p>

<p>根据提示，修改url为：<a href="http://www.pythonchallenge.com/pc/def/274877906944.html">http://www.pythonchallenge.com/pc/def/274877906944.html</a>。</p>

<p>这样就进入下一关了， ^_^)</p>

<p>参考资料：</p>

<p><a href="http://sebug.net/paper/books/dive-into-python3/index.html">深入 Python 3</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac上iOS开发抓包的几种常用方法]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/07/26/iosshe-bei-zhua-bao-de-ji-chong-chang-yong-fang-fa/"/>
    <updated>2014-07-26T21:56:07+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/07/26/iosshe-bei-zhua-bao-de-ji-chong-chang-yong-fang-fa</id>
    <content type="html"><![CDATA[<p>在iOS开发中，经常需要抓包来查看网络请求、应答的情况，例如坚持服务端应答数据、服务端应答速度、客户端发生请求、流量检测、安全性检测等等。不论代码内如何实现，抓包能够最好的证实一切，往往可以更快地定位问题，解决问题。下面总结几种常用的抓包方法。</p>

<h2>使用charles抓包</h2>

<p>在mac下，<a href="http://www.charlesproxy.com/">charles</a>是一个非常好用的抓取http/https请求的工具。</p>

<p>限制条件：</p>

<ul>
<li>需要mac与iOS设备连接相同的无线网络</li>
<li>只能抓取http/https的数据包</li>
<li>无法抓取2G/3G/4G网络下得数据</li>
</ul>


<p>［注］：更多关于charles的使用方法参照<a href="http://www.charlesproxy.com/documentation/">http://www.charlesproxy.com/documentation/</a></p>

<h2>使用RVI（Remote Virtual Interface）+wireshark抓包</h2>

<p>在iOS5以后，Apple为iOS引入了RVI（Remote Virtual Interface），只要设备通过USB连接到Mac，就可以虚拟出一个远程端口，这样就可以在Mac上使用Wireshark抓取这个远程虚拟端口的数据包了。</p>

<p>限制条件：</p>

<ul>
<li>支持的设备系统iOS5以及之后</li>
</ul>


<h2>使用tcpdump命令抓包</h2>

<p>限制条件：</p>

<ul>
<li>需要iOS设备越狱</li>
</ul>


<h2>小结</h2>

<p>以上是平时常用到得几种抓包方法，各有优缺点，可以根据需要选择最方便的方法。</p>

<h2>参考资料</h2>

<p><a href="http://www.charlesproxy.com/">http://www.charlesproxy.com/</a></p>

<p><a href="http://www.charlesproxy.com/documentation/">http://www.charlesproxy.com/documentation/</a></p>

<p><a href="http://www.wireshark.org/">http://www.wireshark.org/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用UIMotionEffect实现设备的倾斜视差]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/02/16/shi-yong-uimotioneffect/"/>
    <updated>2014-02-16T18:28:08+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/02/16/shi-yong-uimotioneffect</id>
    <content type="html"><![CDATA[<p>iOS7更新后，当倾斜手机的时候，会看到屏幕上的背景图片会随着手机的倾斜度而移动，产生视差。刚开始更新的时候，还以为是自己的错觉，－－！。</p>

<p>UIMotionEffect就像它的名字一样，处理motion effect。UIMotionEffect是一个抽象的基类，子类通过重写<code>keyPathsAndRelativeValuesForViewerOffset:</code>方法，当检测到动作的时候</p>

<p>苹果提供了一个子类UIInterpolatingMotionEffect，通过它我们可以实现对设备水平和竖直方向倾斜。</p>

<pre><code>UIInterpolatingMotionEffect *horizontalMotionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];
horizontalMotionEffect.minimumRelativeValue = @(-50);
horizontalMotionEffect.maximumRelativeValue = @(50);
[redView addMotionEffect:horizontalMotionEffect];
</code></pre>

<p><a href="http://www.teehanlax.com/blog/introduction-to-uimotioneffect/">http://www.teehanlax.com/blog/introduction-to-uimotioneffect/</a>
<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffect_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013376">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffect_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013376</a>
<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffectGroup_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013378">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffectGroup_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013378</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用NSLog打印CGPoint、CGSize、CGRect]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/18/use-nslog-to-print-cgpoint-cgrect/"/>
    <updated>2014-01-18T22:02:46+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/18/use-nslog-to-print-cgpoint-cgrect</id>
    <content type="html"><![CDATA[<p>平时调试程序的时候，经常会使用NSLog打印出来。当有CGPoint、CGSize、CGRect对象要打印时，一般要写成下面的方式：</p>

<pre><code>CGPoint point = CGPointMake(0, 20);
NSLog(@"Point: x=%f, y=%f", point.x, point.y);

CGSize size = CGSizeMake(200, 100);
NSLog(@"Size: w=%f, h=%f", size.width, size.height);

CGRect rect = CGRectMake(0, 0, 200, 100);
NSLog(@"Rect: x=%f, y=%f, w=%f, h=%f", rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
</code></pre>

<p>今天看到一篇文章：<a href="http://iosdevelopertips.com/debugging/how-to-use-nslog-to-debug-cgrect-and-cgpoint.html">How to Use NSLog to Debug CGRect and CGPoint</a>，才了解到有一些其他方便的方法。</p>

<pre><code>CGPoint point = CGPointMake(0, 20);
NSLog(@"Point: %@", NSStringFromCGPoint(point));

CGSize size = CGSizeMake(200, 100);
NSLog(@"Size: %@", NSStringFromCGSize(size));

CGRect rect = CGRectMake(0, 0, 200, 100);
NSLog(@"Rect: %@", NSStringFromCGRect(rect));
</code></pre>

<p>打印结果：</p>

<pre><code>Point: {0, 20}
Size: {200, 100}
Rect: \{\{0, 0\}, \{200, 100\}\}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发中一些常用的宏定义]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/18/ioskai-fa-zhong-%5B%3F%5D-xie-chang-yong-de-hong-ding-yi/"/>
    <updated>2014-01-18T21:55:51+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/18/ioskai-fa-zhong-[?]-xie-chang-yong-de-hong-ding-yi</id>
    <content type="html"><![CDATA[<p>Debug输出：</p>

<pre><code>#ifdef DEBUG
    #define debug(format, ...) CFShow([NSString stringWithFormat:format, ## __VA_ARGS__]);
    #define debugAlert(format, ...)  {UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@"%s\n line: %d ", __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:format, ##__VA_ARGS__]  delegate:nil cancelButtonTitle:@"Done" otherButtonTitles:nil]; [alert show]; [alert release];}
#else
    #define debug(format, ...) 
    #define debugAlert(format, ...)
#endif
</code></pre>

<p>检测是否支持ARC：</p>

<pre><code>#if __has_feature(objc_arc)
    // ARC
#else
    // No ARC
#endif
</code></pre>

<p><a href="http://iosdevelopertips.com/debugging/remove-debug-code-for-release-build.html">http://iosdevelopertips.com/debugging/remove-debug-code-for-release-build.html</a></p>

<p><a href="http://iosdevelopertips.com/debugging/display-debug-information-in-uialertview.html">http://iosdevelopertips.com/debugging/display-debug-information-in-uialertview.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Properties to a Category Using Associated Objects]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/16/adding-properties-to-a-category-using-associated-objects/"/>
    <updated>2014-01-16T22:39:50+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/16/adding-properties-to-a-category-using-associated-objects</id>
    <content type="html"><![CDATA[<h2>Object-C中的Category</h2>

<p>Object-C中的Category，相信大家一定不会陌生。一般来说，我们可以用它来为一个类添加新的方法：</p>

<pre><code>@interface NSString (NumberUtils)
- (BOOL)isNumeric; 
@end

@implementation NSString (NumberUtils) 
- (BOOL)isNumeric
{
    NSScanner *scanner = [NSScanner scannerWithString:self];
    return [scanner scanFloat:NULL]? [scanner isAtEnd]: NO;
}
@end
</code></pre>

<p>我们也可以Category中定义新的数据成员，但是不能够对它们使用synthesize。这是因为一个类的结构已经在编译器决定了，而Category是在运行期定义生成的，这样就没有办法改变类结构体中的ivars。</p>

<pre><code>struct objc_class {  
    Class isa  OBJC_ISA_AVAILABILITY;  

    #if !__OBJC2__  
    Class super_class                                        OBJC2_UNAVAILABLE;  
    const charchar *name                                     OBJC2_UNAVAILABLE;  
    long version                                             OBJC2_UNAVAILABLE;  
    long info                                                OBJC2_UNAVAILABLE;  
    long instance_size                                       OBJC2_UNAVAILABLE;  
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;  
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;  
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;  
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;  
#endif  

} OBJC2_UNAVAILABLE;    
</code></pre>

<p>可以向下面这样定义：</p>

<pre><code>@interface NSString (NumberUtils)
@property (nonatomic, readonly, getter=isNumeric) BOOL numeric;
@end
</code></pre>

<p>如果我们想为一个类真正添加一个数据成员，要怎么办呢？当然你可能会想到使用修饰者，封装出一个对象，包含这个类和想要添加的数据成员。但是那样要麻烦一些。</p>

<h2>使用Associated Objects为一个分类添加数据成员</h2>

<p>使用Runtime来解决这个问题。要使用的API：</p>

<pre><code> // 使用一个key值和关联策略来为一个对象设置一个关联的值
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
</code></pre>

<p><code>objc_setAssociatedObject</code>：使用一个key值和关联策略来为一个对象设置一个关联的值。类似NSDictionry，一个key值，对应一个value值。</p>

<p>key值必须是进程的生命周期内一个唯一、不变的id值。可以使用一个NSString对象作为一个key值。但是如果试图通过一个相同的字符串值，但是不同内存地址作为key值，可能不会获得预期的结果。一个更好的选择是定义一个static的指针作为key值。</p>

<p>下面一个例子：</p>

<pre><code>@interface UIImage (Tagged)
@property (nonatomic, copy) NSString *tag;
@end    

#import &lt;objc/runtime.h&gt; 

static const void *ImageTagKey = &amp;ImageTagKey;
@implementation UIImage (Tagged)

- (void)setTag:(NSSting *)tag
{
    objc_setAssociatedObject(self, ImageTagKey, tag, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (NSString *)tag
{
    return objc_getAssociatedObject(self, ImageTagKey);
}
@end
</code></pre>

<p>这个例子中有一点点需要主要：</p>

<ul>
<li>key值使用一个指针类型static const void * 。我们必须让这个指针初始化，否则它的值就会为NULL，但是我们不关心具体指向什么，只要它是唯一的，不变的。这里面，指针指向了自己，一个唯一、不变的值。</li>
</ul>


<p>参考文章：</p>

<p><a href="https://developer.apple.com/library/ios/documentation/cocoa/reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/constant_group/Associative_Object_Behaviors">Objective-C Runtime Reference</a></p>

<p><a href="http://iosdevelopertips.com/objective-c/adding-properties-category-using-associated-objects.html">Adding Properties to a Category Using Associated Objects</a></p>

<p><a href="http://nshipster.com/associated-objects/">Associated Objects</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa简介]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/12/reactivecocoajian-jie/"/>
    <updated>2014-01-12T22:40:40+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/12/reactivecocoajian-jie</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年读过的好书]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/12/2013nian-du-guo-de-hao-shu/"/>
    <updated>2014-01-12T16:45:59+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/12/2013nian-du-guo-de-hao-shu</id>
    <content type="html"><![CDATA[<h2>技术类书籍</h2>

<p>首先时技术类书籍：</p>

<ul>
<li>《从小工到专家——程序员修炼之道》：</li>
<li>《Head First 设计模式》：</li>
<li>《iOS 高级编程》：</li>
<li>《Python》：</li>
<li>《STL源码剖析》：</li>
</ul>


<h2>非技术类书籍</h2>

<p>非技术类：</p>

<ul>
<li>《一个人的村庄》：</li>
<li>《1984》：</li>
<li>《少有人走的路：》：</li>
<li>《自由在高处》：</li>
<li>《九种孤独》：</li>
<li>《天才在左，疯子在右》：</li>
<li>《猎命师传奇：卷二十》：</li>
<li>《上帝掷骰子吗》：</li>
<li>《沉默的大多数》：</li>
<li>《变身》、《新参者》：</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP的缓存机制]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/12/http-cache/"/>
    <updated>2014-01-12T13:56:24+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/12/http-cache</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>HTTP的缓存机制，主要体现在HTTP协议头里面的几个字段——Expires、Cache-control、Last-Modified/If-Modified-Since、Etag/If-None-Match等。在移动开发中，了解HTTP的缓存对开发者来说已经必不可少。</p>

<p><img src="http://Hydra2050.github.io/images/2014011216.png" alt="HTTP HEAD" /></p>

<h2>Expires</h2>

<p>HTTP头中的Expires字段，告诉浏览器在Expires显示的时间前，浏览器可以从缓存中读取，而不需要再次去请求。</p>

<h2>Cache-control</h2>

<p>Cache-control与Expires一样，都是告诉浏览器有效期。不过它不只是设置过期时间，还可以设置很多选项：</p>

<ul>
<li>no-cache指示请求或响应消息不能缓存</li>
<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>
<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>
<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>
<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>
</ul>


<p>如上图：max-age＝600，表示600s内不需要重新请求。</p>

<h2>Last-Modified</h2>

<p><code>Last-Modified</code>：资源的最后修改时间。</p>

<p>如果本地缓存已经过期，即超过了<code>max-age</code>的缓存时间，缓存的HTTP头中存在Last-Modified，则向服务器发送带有If-Modified-Since字段的请求，后面带上<code>Last-Modified</code>所记录的最后修改时间。</p>

<p>服务器收到带有<code>If-Modified-Since</code>的HTTP请求，会将请求的资源修改时间与<code>If-Modified-Since</code>时间对比：如果这段时间没有被修改过，则返回304，告诉浏览器可以继续使用本地缓存；如果资源已经修改过了，则响应请求的资源数据，返回200 OK.</p>

<h2>Etag</h2>

<p><code>Etag</code>：服务器应答数据的时候，生成的当前资源的唯一标识。</p>

<p>如果本地缓存已经过期，即超过了<code>max-age</code>的缓存时间，缓存的HTTP头中存在<code>Etag</code>，则向服务器发送带有<code>If-None-Match</code>字段的请求，后面带上<code>Etag</code>所记录的当前资源的唯一标识。</p>

<p>服务器收到带有<code>If-None-Match</code>的HTTP请求，会将请求的资源唯一标识与<code>If-None-Match</code>的标签的标识对比：如果这段时间没有被修改过，则返回304，告诉浏览器可以继续使用本地缓存；如果资源已经修改过了，则响应请求的资源数据，返回200 OK。</p>

<h2>Etag与Last-Modified的区别？</h2>

<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>

<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>


<p><code>Etag</code>是服务器生成的对应资源的唯一标识符，能够更加准确的控制缓存。<code>Last-Modified</code>与<code>ETag</code>是可以一起使用的，服务器会优先验证<code>ETag</code>，一致的情况下，才会继续比对<code>Last-Modified</code>。</p>

<h2>跳转、刷新、强制刷新</h2>

<p>浏览器缓存行为还有用户的行为有关:</p>

<table>
<thead>
<tr>
<th>用户操作      </th>
<th align="center"> Expires/Cache-control </th>
<th align="center"> Last-Moified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址栏回车     </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>页面链接跳转   </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效  </td>
</tr>
<tr>
<td>新开窗口      </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>前进、后退     </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效 </td>
</tr>
<tr>
<td>F5刷新        </td>
<td align="center"> 无效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>Ctrl＋F5刷新  </td>
<td align="center"> 无效                  </td>
<td align="center"> 无效 </td>
</tr>
</tbody>
</table>


<h2>总结</h2>

<p>当本地存在缓存的时候，一次请求的流程：</p>

<p><img src="http://Hydra2050.github.io/images/HTTPCache.png" alt="HTTP Cache" /></p>

<p>参考：<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">Cache-Control section of RFC 2616</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object-C高级编程学习笔记(三)]]></title>
    <link href="http://Hydra2050.github.io/blog/2013/12/29/object-cgao-ji-bian-cheng-xue-xi-san/"/>
    <updated>2013-12-29T18:56:57+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2013/12/29/object-cgao-ji-bian-cheng-xue-xi-san</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object-C高级编程学习笔记(二)]]></title>
    <link href="http://Hydra2050.github.io/blog/2013/12/22/object-cgao-ji-bian-cheng-xue-xi-2/"/>
    <updated>2013-12-22T20:48:19+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2013/12/22/object-cgao-ji-bian-cheng-xue-xi-2</id>
    <content type="html"><![CDATA[<h1>Blocks</h1>

<h2>What is blocks</h2>

<h3>Block语法</h3>

<p>Blocks是C语言的扩充功能：带有自动变量（局部变量）的匿名函数。</p>

<p><code>^</code> <code>返回值类型</code> <code>参数列表</code> <code>表达式</code></p>

<pre><code>^int (int count) {return count + 1;}
</code></pre>

<p>Block语法可以省略几个项目。首先是返回值类型：</p>

<pre><code>^(int count) {return count + 1;}
</code></pre>

<p>其次，如果不使用参数，参数列表可以省略：</p>

<pre><code>^{ print(“Block\n”);}
</code></pre>

<p>使用Block语法讲Block赋值为Block类型变量：</p>

<pre><code>int(^blk) (int) = ^(int count) {return count + 1;}
int(^blk1) (int) = blk;
</code></pre>

<p>使用typedef定义：</p>

<pre><code>typedef int (^blk_t) (int);
blk_t blk = ^(int count) {return count + 1;}
int nResult = blk(10);
</code></pre>

<p>Block类型变量可以像C语言中其他类型变量一样使用。</p>

<h3>截获自动变量值</h3>

<p>Blocks中，Block表达式截获所使用的自动变量的值。因为Block表达式保存了自动变量的值，所以在执行Block语法后，即使改写Block中使用的自动变量的值也不会影响Block执行时自动变量的值。</p>

<pre><code>int a = 10;
int b = 10;
int (^blk) (void) = ^(return a + b;);
b = 2;
blk();
</code></pre>

<p>执行结果为：<code>20</code></p>

<h3>__block说明符</h3>

<p>若想在Block语法的表达式中将值赋给Block语法外的自动变量，需要在自动变量附加<strong>block说明符，该变量成为</strong>block变量。</p>

<pre><code>__block int val = 0;
void(^blk) (void) = ^{val = 1;};
blk();
printf("%d",val);
</code></pre>

<p>执行结果为： <code>1</code></p>

<p>赋值给截获的自动变量会产生编译错误：</p>

<pre><code>id array = [[NSMutableArray alloc] init];
void (^blk) {array = [[NSMutableArray alloc] init]};
</code></pre>

<p>会出现编译错误。</p>

<p>另外，在使用C语言数组时，必须小心使用起指针。</p>

<pre><code>const char text[] = "Hello";
void (^blk) (void) = ^{
    printf("%c\n",text[2]);
};
</code></pre>

<p>在现在的Block中，截获自动变量的方法并没有实现对C语言数组的截获，因此会编译出错。可以使用指针解决：</p>

<pre><code>const char *text = "Hello";
void (^blk) (void) = ^{
    printf("%c\n",text[2]);
};  
</code></pre>

<h2>Blocks的实现</h2>

<p>// TODO:需要一些时间理解</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object-C高级编程学习笔记(一)]]></title>
    <link href="http://Hydra2050.github.io/blog/2013/12/22/object-cgao-ji-bian-cheng/"/>
    <updated>2013-12-22T14:28:55+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2013/12/22/object-cgao-ji-bian-cheng</id>
    <content type="html"><![CDATA[<p>书名：《Object-C高级编程 IOS与OS X多线程和内存管理》</p>

<h2>ARC</h2>

<p>在Object-C中采用Automatic Reference Counting(ARC)机制，让编译器来进行内存管理。</p>

<ol>
<li>使用Xcode4.2或以上版本</li>
<li>使用LLVM编译器3.0或以上版本</li>
<li>编译器选项中设置ARC为有效</li>
</ol>


<h3>所有权修饰符</h3>

<ul>
<li>__strong修饰符</li>
<li>__weak修饰符</li>
<li>__unsafe_unretained修饰符</li>
<li>__autoreleasing修饰符</li>
</ul>


<h4>1. __strong修饰符</h4>

<p>__strong修饰符为id类型和对象类型默认的所有权修饰符,可以省略。</p>

<pre><code>id __strong obj = [[NSObject alloc] init];
</code></pre>

<h4>2. __weak修饰符</h4>

<p>如果只用__strong修饰符，自动引用计数式内容管理必然会发生“循环引用”的问题。</p>

<p>__weak提供弱引用，弱引用不能持有对象实例，可以解决“循环引用”的问题。</p>

<p>下面这段代码：</p>

<pre><code>id __weak obj = [[NSObject alloc] init];
NSLog(@"%@",obj);
</code></pre>

<p>会输出 nil 。因为__weak修饰的obj持用弱引用，在赋值过后，并没有对象强引用它，生成的对象会立即释放。这样obj自动赋值为nil。</p>

<p>再来看看下面这段代码的输出：</p>

<pre><code>id __weak obj0 = nil;
{
    id __strong obj1 = [[NSObject alloc] init];
    obj0 = obj1;
    NSLog(@"%@",obj0);
}
NSLog(@"%@",obj0);
</code></pre>

<p>结果：</p>

<pre><code>&lt;NSObject: 0x109420000&gt;
nil
</code></pre>

<p>注：<strong>weak修饰符只能用于IOS5以上以及OS X Lion以上版本的应用程序。在它们一下的程序可使用</strong>unsafe_unretained修饰符来代替。</p>

<h4>3. __unsafe_unretained修饰符</h4>

<p><strong>unsafe_unretained修饰符，是不安全的所有权修饰符。有</strong>unsafe_unretained修饰符的变量不属于编译器的内存管理对象。</p>

<pre><code>id __unsafe_unretained obj = [[NSObject alloc] init];
NSLog(@"%@",obj);
</code></pre>

<p>这里和__weak一样，会输出<code>nil</code>。难道这两个修饰符相同吗？再来看第二个例子：</p>

<pre><code>id __unsafe_unretained obj0 = nil;
{
    id __strong obj1 = [[NSObject alloc] init];
    obj0 = obj1;
    NSLog(@"%@",obj0);
}
NSLog(@"%@",obj0);
</code></pre>

<p>输出：</p>

<pre><code>&lt;NSObject: 0x10972ced0&gt;
&lt;NSObject: 0x10972ced0&gt;
</code></pre>

<p>可以看到结果已经和__weak不同。</p>

<p>这里在第二次打印的时候，obj0已经成为一个野指针。</p>

<p><strong>weak与</strong>unsafe_unretained的区别可以简单地说：</p>

<p>当弱引用的对象被释放，<strong>weak修饰的对象会自动赋值为nil；而</strong>unsafe_unretained修饰的对象不会。</p>

<h4>4. __autoreleasing修饰符</h4>

<p>在ARC有效的时候，不能使用NSAutoreleasePool。为了实现想非ARC工程的NSAutoreleasePool该怎么办？使用__autoreleasing修饰符。</p>

<p>一下两段代码效果相同：</p>

<pre><code>/* NO ARC */
NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];
[pool drain];

/*  ARC  */
@autoreleasepool {
    id __autoreleasing obj = [[NSObject alloc] init];
}
</code></pre>

<p>但是，显式地附加<strong>autoreleasing修饰符同显式地附加</strong>strong一样罕见。一般不必显示地添加__autoreleasing修饰符。</p>

<p style="color:red"> 另外，无论ARC是否有效，调试用的私有方法_objc_autoreleasePoolPrint()都可以使用。利用这个函数可以有效地帮助我们调试注册到autoreleasepool上的对象。 </p>


<h3>ARC的规则</h3>

<p>1. 不能使用retain/release/retainCount/autorelease</p>

<p>2. 不能使用NSAllocateObject/NSDeallocateObject</p>

<p>3. 遵守内存管理的方法命名规则</p>

<p>4. 不要显示调用dealloc</p>

<p>5. 使用@autoreleasepool快代替NSAutoreleasePool</p>

<p>6. 不能使用NSZone</p>

<p>7. 对象型变量不能作为C语言结构体的成员</p>

<p>要把对象型变量加入到结构体成员，可强制转换为void* 或是添加<code>__unsafe_unretained</code>修饰符。</p>

<h4>显示转换id 和 void*</h4>

<p>下面这段代码，在ARC下会编译错误：</p>

<pre><code>id obj = [[NSObject alloc] init];
void* p = obj;
</code></pre>

<p>需要使用“__bridge转换”：</p>

<p>1、 __bridge</p>

<pre><code>/* ARC */
id obj1 = [[NSObject alloc] init];
void* p = (__bridge void*)obj1;
</code></pre>

<p>相当于：</p>

<pre><code>/* NO ARC */
id obj = [[NSObject alloc] init];
void* p = obj;
</code></pre>

<p>但是使用<strong>bridge转换，其安全性与赋值</strong>unsafe_unretained修饰符相似，甚至更低。</p>

<p>2、 __bridge_retained</p>

<pre><code>/* ARC */
id obj1 = [[NSObject alloc] init];
void* p = (__bridge_retained void*)obj1;
</code></pre>

<p>相当于：</p>

<pre><code>/* NO ARC */
id obj1 = [[NSObject alloc] init];
void* p = obj1;
[(id)p retain];
</code></pre>

<p>下面的代码：</p>

<pre><code>void* p = 0;
{
    id obj1 = [[NSObject alloc] init];
    void* p = (__bridge_retained void*)obj1;
}
NSLog(@"%@",p);
</code></pre>

<p>由于使用__bridge_retained，p在对后持有该对象，所以会打印出该对象。</p>

<p>3、 __bridge_transfer</p>

<pre><code>/* ARC */
id obj1 = [[NSObject alloc] init];
void* p = (__bridge_transfer void*)obj1;
</code></pre>

<p>相当于：</p>

<pre><code>id obj1 = [[NSObject alloc] init];
void* p = obj1;
[(id)p retain];
[obj1 release];
</code></pre>

<p>当然可是实现双向的转换。这些转换多数使用在Objec-C对象和Core Foundation对象之间的互相转换。</p>

<p>以下两个函数为系统提供的方法，实现Toll-Free Bridging：</p>

<pre><code>NS_INLINE id CFBridgingRelease(CFTypeRef CF_CONSUMED X) {
return (__bridge_transfer id)X;
}
NS_INLINE CF_RETURNS_RETAINED CFTypeRef CFBridgingRetain(id X) {
return (__bridge_retained CFTypeRef)X;
}
</code></pre>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">Toll-Free Bridging</a></p>

<h3>属性</h3>

<p>ARC中，属性声明的属性与所有权修饰符的关系</p>

<table>
<thead>
<tr>
<th align="center">   属性声明   </th>
<th align="center"> 所有权修饰符           </th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">assign           </td>
<td align="center"> __unsafe_unretained  </td>
</tr>
<tr>
<td align="center">copy             </td>
<td align="center"> __strong(复制对象)    </td>
</tr>
<tr>
<td align="center">retain           </td>
<td align="center"> __strong             </td>
</tr>
<tr>
<td align="center">strong           </td>
<td align="center"> __strong             </td>
</tr>
<tr>
<td align="center">unsafe_unretained</td>
<td align="center"> __unsafe_unretained </td>
</tr>
<tr>
<td align="center">weak             </td>
<td align="center"> __weak               </td>
</tr>
</tbody>
</table>


<p style="color:red">有一种情况不能使用__weak修饰符：</p>


<p></p>

<pre><code>- (BOOL)allowsWeakReference UNAVAILABLE_ATTRIBUTE;
- (BOOL)retainWeakReference UNAVAILABLE_ATTRIBUTE;
</code></pre>

<p>如果NSobject实例上面的两个方法返回NO，绝对不能使用__weak修饰符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS7 New Feature: iBeacon]]></title>
    <link href="http://Hydra2050.github.io/blog/2013/12/21/ios7-new-feature-ibeacon/"/>
    <updated>2013-12-21T18:32:32+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2013/12/21/ios7-new-feature-ibeacon</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>iBeacon作为IOS7的一项新特性，在今年的WWDC大会上正式正式发布。虽然官方对它的描述并不多，WWDC的视频中也没有一个是讲解iBeacon的，但是在WWDC2013的Keynote上还是看到了它的身影。</p>

<p><img src="http://Hydra2050.github.io/images/201312211904.jpeg" alt="WWDC2013 Keynote" /></p>

<p>iBeacon也是我今年WWDC上最喜欢的新特性之一，因为我一直认为更便捷、去中心化的沟通才是未来。在IOS7推出Beta版的时候，我也曾经实践过新推出的Nearby Networking With Multipeer Connectivity。但是相比之下，iBeacon要优秀很多。</p>

<p>目前有不少硬件厂商在生产基于iBeacon的基站，Estimote很早就推出了Estimote Beacons，利用苹果的iBeacon技术，实现Distance、Proximity和Notification三种功能。如果想体验一下，可以在Appstore搜索下载应用Estimote。同时Estimote Beacons提供了一套API，可以方便地进行编程。</p>

<p><a href="https://github.com/Estimote/iOS-SDK">Estimote Beacons的API地址</a></p>

<p><img src="http://Hydra2050.github.io/images/201312211906.jpeg" alt="Estimote Beacons" /></p>

<h2>What is iBeacon?</h2>

<p>iBeacon通过使用低功耗蓝牙技术（Bluetooth Low Energy，也就是通常所说的Bluetooth 4.0或者Bluetooth Smart），可以创建一个信号区域，当设备进入该区域时，相应的应用程序便会提示用户是否需要接入这个信号网络。通过能够放置在任何物体中的小型无线传感器和低功耗蓝牙技术，用户便能使用iPhone来传输数据。</p>

<p><img src="http://Hydra2050.github.io/images/201312211907.jpeg" alt="iBeacon" /></p>

<h2>什么是低功耗蓝牙技术？</h2>

<p>低功耗蓝牙技术的最大特点便在于低功耗，从而能使设备拥有更长的续航时间。不过低功耗蓝牙技术仅支持较低的文件传输速率，因此可以用于可穿戴式智能设备之间的信息传送，但却不能完成像传输音频这样的任务。</p>

<h2>一个简单的Demo</h2>

<p><a href="https://github.com/Hydra2050/BeaconDemo">Demo下载地址</a></p>

<h3>Start a BeaconBroadcast</h3>

<p>1、 创建一个BeaconRegion，作为Beacon基站的广播的Region对象。其中UUID为Beacon基站的唯一标识。</p>

<pre><code>NSUUID* myUUID = [[NSUUID alloc] initWithUUIDString:@"E621E1F8-C36C-495A-93FC-0C247A3E6E5D"];
self.targetBeaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:myUUID identifier:@"My Beacon Demo 20131221"];
</code></pre>

<p>2、 创建一个CBPeripheralManager对象</p>

<pre><code> self.peripheraManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil];
</code></pre>

<p>3、 开始广播</p>

<pre><code>NSDictionary* peripheraData = [self.boardcastBeaconRegion peripheralDataWithMeasuredPower:nil];
[self.peripheraManager startAdvertising:peripheraData];
</code></pre>

<p>开始广播后，可以处理一下回调函数，如：</p>

<pre><code>- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral
- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error
</code></pre>

<h3>Start a BeaconMonitor</h3>

<p>1、 创建一个BeaconRegion，作为搜索的Region对象。其中UUID为Beacon基站的唯一标识。</p>

<pre><code>NSUUID* myUUID = [[NSUUID alloc] initWithUUIDString:@"E621E1F8-C36C-495A-93FC-0C247A3E6E5D"];
self.targetBeaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:myUUID identifier:@"My Beacon Demo 20131221"];
</code></pre>

<p>2、 创建一个CLLocationManager对象</p>

<pre><code>self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.delegate = self;
</code></pre>

<p>3、 开始搜索Beacon基站</p>

<pre><code>[self.locationManager startRangingBeaconsInRegion:self.targetBeaconRegion];
</code></pre>

<p>接下来可以处理一下回调函数，如：</p>

<pre><code>- (void)locationManager:(CLLocationManager *)manager
    didRangeBeacons:(NSArray *)beacons inRegion:(CLBeaconRegion *)region
- (void)locationManager:(CLLocationManager *)manager
 didUpdateLocations:(NSArray *)locations
- (void)locationManager:(CLLocationManager *)manager
     didEnterRegion:(CLRegion *)region
- (void)locationManager:(CLLocationManager *)manager
      didExitRegion:(CLRegion *)region
- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status
</code></pre>

<p>效果图：</p>

<p><img src="http://Hydra2050.github.io/images/201312211958.PNG" alt="CLProximityImmediate" /></p>

<p><img src="http://Hydra2050.github.io/images/201312211959.PNG" alt="CLProximityNear" /></p>

<p><img src="http://Hydra2050.github.io/images/201312212001.PNG" alt="CLProximityFar" /></p>

<p><img src="http://Hydra2050.github.io/images/201312212002.PNG" alt="CLProximityUnknown" /></p>

<p><img src="http://Hydra2050.github.io/images/201312212003.PNG" alt="didExitRegion" /></p>

<h2>总结</h2>

<p>通过Demo，可以对iBeacon有一个简单的了解。iBeacon可以方便实现室内导航、商品消息推送、支付等功能。网上很多文章认为iBeacon会成为NFC杀手。到底iBeacon能发展到什么地步，让我们拭目以待吧。</p>

<p><a href="http://support.apple.com/kb/HT6048">iOS: Understanding iBeacon</a></p>
]]></content>
  </entry>
  
</feed>
