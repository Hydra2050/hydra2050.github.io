<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[王仙客的博客]]></title>
  <link href="http://Hydra2050.github.io/atom.xml" rel="self"/>
  <link href="http://Hydra2050.github.io/"/>
  <updated>2015-02-10T11:31:32+08:00</updated>
  <id>http://Hydra2050.github.io/</id>
  <author>
    <name><![CDATA[王仙客]]></name>
    <email><![CDATA[wh2050@sina.cn]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用MSWeakTimer一次crash分析]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/10/shi-yong-msweaktimer%5B%3F%5D-ci-crashfen-xi/"/>
    <updated>2015-02-10T11:05:13+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/10/shi-yong-msweaktimer[?]-ci-crashfen-xi</id>
    <content type="html"><![CDATA[<p>最近在使用<a href="https://github.com/mindsnacks/MSWeakTimer">MSWeakTimer</a>的时候，出现了crash的情况，在分析过程中发现了自己之前一直忽略的一些内容，简单做一下记录。</p>

<p>ps：后来在网上查到了两篇文章，很好的解释了这个问题。</p>

<p><a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">http://blog.sunnyxx.com/2015/01/17/self-in-arc/</a></p>

<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p>

<h2>crash过程跟踪</h2>

<p>ARC的工程，大致的调用代码如下：</p>

<pre><code>// ...
// @property (nonatomic, strong) MSWeakTimer *countdownTimer;
// ...
_countdownTimer = [MSWeakTimer scheduledTimerWithTimeInterval:1.0
                                                       target:self
                                                     selector:@selector(timerCountDown:)
                                                     userInfo:nil
                                                      repeats:YES dispatchQueue:dispatch_get_main_queue()];
[_countdownTimer fire];

... 

- (void)timerCountDown:(MSWeakTimer *)timer{
    // ...
    if(shouldDisableTimer){
        [timer invalidate];
        timer = nil;
    }else{
        // ...
    }
}
</code></pre>

<p> 最终崩溃的函数：</p>

<pre><code>- (void)timerFired
{
    // Checking attomatically if the timer has already been invalidated.
    if (OSAtomicAnd32OrigBarrier(1, &amp;_timerFlags.timerIsInvalidated))
    {
        return;
    }

    // We're not worried about this warning because the selector we're calling doesn't return a +1 object.
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self.target performSelector:self.selector withObject:self];
    #pragma clang diagnostic pop

    if (!self.repeats)
    {
        [self invalidate];
    }
}
</code></pre>

<p>崩溃在了<code>if (!strongSelf.repeats)</code>这一句，显示<code>self</code>已经是zombie对象。</p>

<p>断点跟踪发现，在<code>selector</code>中，<code>self</code>被置为<code>nil</code>。那就比较奇怪，拿到<code>self</code>不会在作用域范围内retaincount加1吗？</p>

<h2>crash原因分析</h2>

<p>根据oc的调用机制，第一个参数就是<code>self</code>，但是<code>self</code>作为参数，并不会增加引用计数。这样就解释了上面<code>self</code>为什么成为zombie。</p>

<p>具体的解释可以参照<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self">Clang 3.7 documentation</a>，解释如下图：</p>

<p><img src="http://Hydra2050.github.io/images/20150210_0.png" alt="Clang3.7#self" /></p>

<h2>如何解决crash</h2>

<p>通过增加一个对<code>self</code>的强引用，保证在函数作用域内，<code>self</code>不会被释放。</p>

<pre><code>- (void)timerFired
{
    // Checking attomatically if the timer has already been invalidated.
    if (OSAtomicAnd32OrigBarrier(1, &amp;_timerFlags.timerIsInvalidated))
    {
        return;
    }

    MSWeakTimer *strongSelf = self;
    // We're not worried about this warning because the selector we're calling doesn't return a +1 object.
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self.target performSelector:self.selector withObject:self];
    #pragma clang diagnostic pop

    if (!strongSelf.repeats)
    {
        [strongSelf invalidate];
    }
}
</code></pre>

<h2>深入理解ARC下的Autorelease</h2>

<p>到这里就结束了吗？有意思的在后面！</p>

<p>在不修改<code>MSWeakTimer</code>的情况下，如果将上面的代码：</p>

<pre><code>[_countdownTimer fire];
</code></pre>

<p>改为：</p>

<pre><code>[self.countdownTimer fire];
</code></pre>

<p>运行后就不会崩溃！！！</p>

<p><img src="http://Hydra2050.github.io/images/20150210_1.jpeg" alt="WTF" /></p>

<p>关于Autorelease，下面的内容摘自<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a>。</p>

<h3>AutoreleasePoolPage</h3>

<p>ARC下，我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：</p>

<pre><code>void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
</code></pre>

<p>而这两个函数都是对<code>AutoreleasePoolPage</code>的简单封装，所以自动释放机制的核心就在于这个类。</p>

<p>AutoreleasePoolPage是一个C++实现的类:</p>

<p><img src="http://Hydra2050.github.io/images/20150210_2.jpg" alt="AutoreleasePoolPage" /></p>

<ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<code>双向链表</code>的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的<code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>


<p>所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：</p>

<p><img src="http://Hydra2050.github.io/images/20150210_3.jpg" alt="AutoreleasePoolPage" /></p>

<p>图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的<code>next</code>指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</p>

<p>所以，向一个对象发送<code>- autorelease</code>消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置。</p>

<h3>释放时刻</h3>

<p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的AutoreleasePoolPage中add进一个<code>哨兵对象</code>，值为0（也就是个nil），那么这一个page就变成了下面的样子：</p>

<p><img src="http://Hydra2050.github.io/images/20150210_4.jpg" alt="AutoreleasePoolPage" /></p>

<p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop</code>(哨兵对象)作为入参，于是：</p>

<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page；</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置；</li>
<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page
刚才的<code>objc_autoreleasePoolPop</code>执行后，最终变成了下面的样子：</li>
</ol>


<p><img src="http://Hydra2050.github.io/images/20150210_5.jpg" alt="AutoreleasePoolPage" /></p>

<h3>嵌套的AutoreleasePool</h3>

<p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>

<h3>Autorelease返回值的快速释放机制</h3>

<p>值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。
比如一个工厂方法：</p>

<pre><code>+ (instancetype)createSark {
    return [self new]; 
}
// caller
Sark *sark = [Sark createSark];
</code></pre>

<p>秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：</p>

<pre><code>+ (instancetype)createSark {
    id tmp = [self new];
    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease
}
// caller
id tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain
Sark *sark = tmp;
objc_storeStrong(&amp;sark, nil); // 相当于代替我们调用了release
</code></pre>

<p>一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。</p>

<h3>黑魔法之Thread Local Storage</h3>

<p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：</p>

<pre><code>void* pthread_getspecific(pthread_key_t);
int pthread_setspecific(pthread_key_t , const void *);
</code></pre>

<p>说它是黑魔法可能被懂pthread的笑话- &ndash;</p>

<p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的<code>objc_retainAutoreleasedReturnValue</code>里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。</p>

<p>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。</p>

<p>于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）只能动用更高级的黑魔法。</p>

<h3>黑魔法之__builtin_return_address</h3>

<p>这个内建函数原型是<code>char *__builtin_return_address(int level)</code>，作用是得到函数的返回地址，参数表示层数，如<code>__builtin_return_address(0)</code>表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。</p>

<pre><code>- (int)foo {
    NSLog(@"%p", __builtin_return_address(0)); // 根据这个地址能找到下面ret的地址
    return 1;
}
// caller
int ret = [sark foo];
</code></pre>

<p>看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）</p>

<p>也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。</p>

<p>回到上面的问题，如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理。</p>

<h3>黑魔法之反查汇编指令</h3>

<p>通过上面的<code>__builtin_return_address</code>加某些偏移量，被调方可以定位到主调方在返回值后面的<code>汇编指令</code>：</p>

<pre><code>// caller 
int ret = [sark foo];
// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）
movq ??? ???
callq ???
</code></pre>

<p>而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。</p>

<p>于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值。</p>

<pre><code>static bool callerAcceptsFastAutorelease(const void * const ra0) {
    const uint8_t *ra1 = (const uint8_t *)ra0;
    const uint16_t *ra2;
    const uint32_t *ra4 = (const uint32_t *)ra1;
    const void **sym;
    // 48 89 c7    movq  %rax,%rdi
    // e8          callq symbol
    if (*ra4 != 0xe8c78948) {
        return false;
    }
    ra1 += (long)*(const int32_t *)(ra1 + 4) + 8l;
    ra2 = (const uint16_t *)ra1;
    // ff 25       jmpq *symbol@DYLDMAGIC(%rip)
    if (*ra2 != 0x25ff) {
        return false;
    }
    ra1 += 6l + (long)*(const int32_t *)(ra1 + 2);
    sym = (const void **)ra1;
    if (*sym != objc_retainAutoreleasedReturnValue)
    {
        return false;
    }
    return true;
}
</code></pre>

<p>它检验了主调方在返回值之后是否紧接着调用了｀objc_retainAutoreleasedReturnValue｀，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p>

<h3>其他Autorelease相关知识点</h3>

<p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：</p>

<pre><code>[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    // 这里被一个局部@autoreleasepool包围着
}];
</code></pre>

<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool。</p>

<p><strong>以上一段转载自<a href="http://blog.sunnyxx.com/">sunnyxx</a>的文章！</strong></p>

<h2>解答最后的问题</h2>

<p>根据上面的分析，可以知道，当执行：</p>

<pre><code>[self.countdownTimer fire];
</code></pre>

<p>Autorelease为我们做了：</p>

<pre><code>id tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain
MSWeakTimer *timer = tmp;
[timer fire];
objc_storeStrong(&amp;timer, nil); // 相当于代替我们调用了release
</code></pre>

<p>参考资料：</p>

<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></p>

<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fishhook和Aspects使用简单示例]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/10/fishhookhe-aspectsshi-yong-jian-dan-shi-li/"/>
    <updated>2015-02-10T10:27:11+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/10/fishhookhe-aspectsshi-yong-jian-dan-shi-li</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/fishhook">fishhook</a>: A library that enables dynamically rebinding symbols in Mach-O binaries running on iOS.</p>

<pre><code>#import &lt;dlfcn.h&gt;
#import "fishhook.h"

static OSStatus (*origin_AudioSessionSetProperty)(unsigned long, unsigned long, const void*);

void save_original_symbols() {
    origin_AudioSessionSetProperty = dlsym(RTLD_DEFAULT, "AudioSessionSetProperty");
}

OSStatus my_AudioSessionSetProperty(unsigned long inID, unsigned long inDataSize, const void *inData){
    printf("Calling real AudioSessionSetProperty: inID %ld  \n", inID);

    return origin_AudioSessionSetProperty(inID, inDataSize, inData);
}

int main(int argc, char * argv[]) {
 @autoreleasepool {
       save_original_symbols();
       rebind_symbols((struct rebinding[])AudioSessionSetProperty, 1);

       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
     }
}
</code></pre>

<h1>Aspects</h1>

<p><a href="https://github.com/steipete/Aspects.git">Aspects</a>: Delightful, simple library for aspect oriented programming.</p>

<pre><code>[[AVAudioSession sharedInstance] aspect_hookSelector:@selector(setCategory:withOptions:error:) withOptions:0 usingBlock:^(id&lt;AspectInfo&gt; info,NSString *category, AVAudioSessionCategoryOptions option, NSError ** error){
    NSLog(@"AVAudioSession set category with category : %@", category);
}error:nil];
</code></pre>

<p>需要注意的一点，参数<code>block</code>需要与hook的函数相符，如果不匹配，会有如下提示：</p>

<pre><code>Aspects: Block signature &lt;NSMethodSignature: 0x7f93b8c35c80&gt; doesn't match &lt;NSMethodSignature: 0x7f93b8c33c30&gt;.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从dispatch_get_current_queue()说起]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/10/cong-dispatch-get-current-queue-shuo-qi/"/>
    <updated>2015-02-10T10:12:36+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/10/cong-dispatch-get-current-queue-shuo-qi</id>
    <content type="html"><![CDATA[<p><code>dispatch_get_current_queue</code>从iOS6.0开始被废弃掉，在《Effective Object-C 2.0》中，也单独有一个章节讲解。在队列同步操作的时候，有时需要检查当前的执行队列。在试图使用dispatch_get_current_queue判断当前队列的时候，仍然可能出错。</p>

<h2>使用dispatch_get_current_queue()存在的问题</h2>

<p>先看下面一段代码：</p>

<pre><code>    dispatch_queue_t queueA = dispatch_queue_create("c.b.a", NULL);
    dispatch_queue_t queueB = dispatch_queue_create("c.b.b", NULL);
    dispatch_sync(queueA, ^{
       dispatch_sync(queueB, ^{
           dispatch_block_t block = ^{
              // ...
           };
           dispatch_sync(queueA, ^{
               block();
           });
       });
    });
</code></pre>

<p>运行会发现死锁的情况，尝试使用dispatch_get_current_queue()来解决：</p>

<pre><code>dispatch_sync(queueA, ^{
           dispatch_sync(queueB, ^{
               dispatch_block_t block = ^{
                  // ...
               };
               if(dispatch_get_current_queue() == queueA){
                   block();
               }else{
                   dispatch_sync(queueA, ^{
                       block();
                   });
               }
           });
        });
</code></pre>

<p>运行后发现，同样会死锁。dispatch_get_current_queue判断，当前队列为queueB。</p>

<p>如果把每个队列看做一个管道，将管道B放在管道A中，dispatch_get_current_queue只能看到自己这一层，没法打破管道。</p>

<h2>dispatch_get_specific()试一试</h2>

<p>尝试使用dispatch_get_specific()关联键值对的方式判断当前队列：</p>

<pre><code>    dispatch_queue_t queueA = dispatch_queue_create("c.b.a", NULL);
    dispatch_queue_t queueB = dispatch_queue_create("c.b.b", NULL);
    static int kQueueSpecificA;
    static int kQueueSpecificB;
    dispatch_queue_set_specific(queueA, &amp;kQueueSpecificA, (void *)CFSTR("queueA"), (dispatch_function_t)CFRelease);
    dispatch_queue_set_specific(queueB, &amp;kQueueSpecificB, (void *)CFSTR("queueB"), (dispatch_function_t)CFRelease);
    dispatch_sync(queueA, ^{
       dispatch_sync(queueB, ^{
           dispatch_block_t block = ^{
              // ...
           };
           void *retrievedValueA = dispatch_get_specific(&amp;kQueueSpecificA);
           void *retrievedValueB = dispatch_get_specific(&amp;kQueueSpecificB);
           if(retrievedValueA){
                NSLog(@"queueA");
           }
           if(retrievedValueB){
                NSLog(@"queueB");
           }
           if(retrievedValueA){
               block();
           }else{
               dispatch_sync(queueA, ^{
                        block();
                    });
           }
       });
    });
</code></pre>

<p>运行之后，发现仍然有问题。dispatch_get_specific()仍然无法破壁，窥视外面的管道。</p>

<h2>破壁还需dispatch_set_target_queue()</h2>

<p>dispatch_set_target_queue()将第一个参数指定在第二个参数的队列内执行，同时也使参数A的队列优先级与参数B的队列相同。</p>

<pre><code>dispatch_queue_t queueA = dispatch_queue_create("c.b.a", NULL);
    dispatch_queue_t queueB = dispatch_queue_create("c.b.b", NULL);
    static int kQueueSpecificA;
    static int kQueueSpecificB;
    dispatch_queue_set_specific(queueA, &amp;kQueueSpecificA, (void *)CFSTR("queueA"), (dispatch_function_t)CFRelease);
    dispatch_queue_set_specific(queueB, &amp;kQueueSpecificB, (void *)CFSTR("queueB"), (dispatch_function_t)CFRelease);
    dispatch_set_target_queue(queueB, queueA);
        dispatch_sync(queueB, ^{
            dispatch_block_t block = ^{
                // ...
            };
            void *retrievedValueA = dispatch_get_specific(&amp;kQueueSpecificA);
            void *retrievedValueB = dispatch_get_specific(&amp;kQueueSpecificB);
            if(retrievedValueA){
                NSLog(@"queueA");
            }
            if(retrievedValueB){
                NSLog(@"queueB");
            }
            if(retrievedValueA){
                block();
            }else{
                dispatch_sync(queueA, ^{
                    block();
                });
            }
        });
</code></pre>

<p>  这样执行的结果就没有问题了~</p>

<h2>dispatch_set_target_queue()注意的问题</h2>

<p>执行上面的代码会发现，<code>retrievedValueA</code>和<code>retrievedValueB</code>都不为空。是的，这两个管道已经互通状态了！所以在使用的时候，判断的时候也需要注意。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用MSWeakTimer的一次crash问题解析 ]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/08/shi-yong-msweaktimerde-ci-crashwen-ti-jie-xi/"/>
    <updated>2015-02-08T17:15:02+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/08/shi-yong-msweaktimerde-ci-crashwen-ti-jie-xi</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建和使用私有cocoapods repo]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/08/ru-he-chuang-jian-he-shi-yong-si-you-cocoapods-repo/"/>
    <updated>2015-02-08T15:22:36+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/08/ru-he-chuang-jian-he-shi-yong-si-you-cocoapods-repo</id>
    <content type="html"><![CDATA[<h2>安装cocoapods</h2>

<pre><code>gem update --system
gem sources -l
gem install cocoapods
pod setup
</code></pre>

<h2>创建私有cocoapods repo</h2>

<h3>第一步，创建私有Spec Repo</h3>

<p>在服务器创建repo裸仓库：</p>

<pre><code>mkdir REPO_NAME.git
cd REPO_NAME.git
git init --bare
</code></pre>

<h3>第二步，将私有pod repo添加到本地</h3>

<pre><code>pod repo list
pod repo add REPO_NAME SOURCE_URL
</code></pre>

<h3>第三步，检测pod repo是否正确</h3>

<pre><code>pod repo lint REPO_NAME
</code></pre>

<h2>为私有pod添加新的Spec</h2>

<h3>第一步，创建podspec文件</h3>

<pre><code>pod spec create SPEC_NAME
</code></pre>

<h3>第二步，修改Spec文件</h3>

<h3>第三步，检测Spec文件是否正确</h3>

<pre><code>pod spec lint SPEC_NAME
</code></pre>

<h3>第四步，上传Spec文件至私有pod repo</h3>

<pre><code>pod repo push REPO_NAME SPEC_NAME.podspec
</code></pre>

<p>因为我使用的时<code>ssh</code>URL获取，会产生<code>warning</code>：</p>

<pre><code>    - WARN  | [source] Git SSH URLs will NOT work for people behind firewalls configured to only allow HTTP, therefore HTTPS is preferred.
</code></pre>

<p>可以忽略这个警告：</p>

<pre><code>pod repo push --allow-warnings REPO_NAME SPEC_NAME.podspec
</code></pre>

<h2>spec lint 技巧</h2>

<p>在执行<code>pod spec line xxx</code>的时候出错，但提示往往比较简单，可以添加参数<code>--no-clean</code>：</p>

<pre><code>pod spec lint --no-clean xxx
</code></pre>

<p>执行完成后，根据提示的路径，打开lint生成的工程文件，编译查看出错的原因。</p>

<p>一般路径为：<code>/private/tmp/CocoaPods/Lint/Pods/Pods.xcodeproj</code>。</p>

<p>参考链接：<a href="http://guides.cocoapods.org/making/private-cocoapods.html">http://guides.cocoapods.org/making/private-cocoapods.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何提高pod install执行速度]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/02/08/ru-he-ti-gao-pod-installzhi-xing-su-du/"/>
    <updated>2015-02-08T14:05:04+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/02/08/ru-he-ti-gao-pod-installzhi-xing-su-du</id>
    <content type="html"><![CDATA[<p>应用集成了cocoapods一段时间，发现每次执行<code>pod insgtall</code>命令都会比较慢，有时要等十多分钟甚至更久，严重影响工作效率和开发的心情。</p>

<h2><code>pod install</code>执行慢的原因</h2>

<p>Cocopods的<code>pod install</code>命令一般分两步：</p>

<ol>
<li>执行<code>pod repo update</code>，更新本地的repo Spec文件（<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>）</li>
<li>根据spec的配置，获取源文件，一般是通过git clone的方式从github上下载第三方库</li>
</ol>


<p>由于<code>GWF</code>的存在，经常存在github无法访问的情况；有时可以访问，速度也比较慢。人生苦短！！</p>

<p>可以针对这两方面进行提高<code>pod install</code>执行速度。</p>

<h2>减少pod repo update的次数</h2>

<p>执行<code>pod repo update</code>是必要的，保证每次安装的时候，能够获取最新的Spec文件。但不必每次都执行，建议每天执行一次。在执行<code>pod install</code>的时候添加参数，不再执行<code>pod repo update</code>：</p>

<pre><code>pod install --no-repo-update
</code></pre>

<h2>使用本地的git mirror解决下载慢的问题</h2>

<p>解决了repo更新的问题，仍然存在一系列问题：</p>

<ul>
<li>将源文件克隆到本地速度缓慢</li>
<li>一旦被托管在github上的第三方库被删除掉，我们将再也无法获取到第三方库</li>
<li>如果访问外网的网络暂时性的中断，无法执行<code>pod install</code>，影响正常开发</li>
</ul>


<p>为了解决以上问题，在公共服务器上搭建了一个GitMirror，为每一个使用到的第三方库创建一个mirror仓库。以后每次执行install的时候，实际都是从本地服务器下载，速度就会有明显的提升。</p>

<h3>修改本地spec配置</h3>

<p>第一步要将第三库的源文件下载地址修改为本地服务器。写了一个脚本<code>moveToGitMirror.py</code>自动完成本地spec配置修改。执行命令如下：</p>

<pre><code>cd ~/.cocoapods/repos/master/
python moveToGitMirror.py
</code></pre>

<p>这个脚本的功能很简单，遍历当前目录下的文件，查找后缀名为.spec.json的文件，查找到source路径，然后修改为镜像地址。</p>

<p>这里需要注意的是，一旦修改，将完全依赖镜像的服务器。可以替换成一个指定的域名，而不是一个固定的ip地址。这样通过修改本地<code>hosts</code>文件，实现source路径的整体切换。</p>

<h3>为一个第三方库创建git mirror</h3>

<p>如果项目中需要一个第三方库，以<code>Masonry</code>为例。</p>

<pre><code>ssh root@xx.xx.xx.xx
cd GitRepoMirror/
git clone --mirror https://github.com/Masonry/Masonry.git
</code></pre>

<h3>设置免密码远程访问</h3>

<p>完成以上的操作，执行<code>pod install</code>，会发现下载一个第三方库都需要我们输入一次密码。what？？？太烦了！</p>

<p>为了实现免密码远程访问，我们需要把本机的rsa公钥放入远程服务器的<code>authorized_keys</code>文件下。如果本机没有生产过rsa密钥，执行以下命令：</p>

<pre><code>ssh-keygen -t rsa -C "xxx.com"
</code></pre>

<h2>下一步</h2>

<p>下一步，可以创建一个属于自己的私有pod repo了，以后再介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImagePickerController cause idleTimerDisabled setting problem]]></title>
    <link href="http://Hydra2050.github.io/blog/2015/01/10/uiimagepickercontroller-cause-idletimerdisabled-setting-not-working/"/>
    <updated>2015-01-10T10:48:27+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2015/01/10/uiimagepickercontroller-cause-idletimerdisabled-setting-not-working</id>
    <content type="html"><![CDATA[<p>前一段时间，遇到了一个奇怪的问题：在程序里设置了<code>idleTimerDisabled</code>为<code>YES</code>，但是还是有用户反馈，程序会自动锁屏。测试也曾反馈，曾经遇到过这个问题，但一直未找到重现方法。在Stackoverflow看到，与UIImagePickerController的使用有关。</p>

<h2>重现</h2>

<p>设置<code>idleTimerDisabled</code>为<code>YES</code>，创建UIImagePickerController，设置sourceType为<code>UIImagePickerControllerSourceTypeCamera</code>，然后弹出拍照页面。拍照页面关闭后，等待自动锁屏的出现。</p>

<h2>分析</h2>

<p>设置断点:</p>

<pre><code>-[UIApplication setIdleTimerDisabled:]
</code></pre>

<p><img src="http://Hydra2050.github.io/images/20150110_1.png" alt="idleTimer breakpoint" /></p>

<p>运行后会发现，在UIImagePickerController弹出的时候，进入一次断点。使用LLDB命令(因为我用的是arm64的机器，所以寄存器为x，如果是armv7，为r)：</p>

<pre><code>po $x0
&lt;UIApplication: 0x156e008e0&gt;

p (SEL)$x1
(SEL) $1 = "setIdleTimerDisabled:"

po $x2
1
</code></pre>

<p>在弹出UIImagePickerController的时候，系统会自动将<code>idleTimerDisabled</code>设置为<code>YES</code>。</p>

<p>继续运行，关闭UIImagePickerController，由于这只的animation为<code>YES</code>，会进入两次断点。两次的参数相同，都为<code>nil</code>。</p>

<pre><code>po $x2
nil
</code></pre>

<p>这就会将<code>idleTimerDisabled</code>设置为<code>NO</code>，导致之前设置的值被修改。</p>

<h2>解决</h2>

<p>目前想到的解决方法，在UIImagePickerController消失后，重新设置idleTimerDisabled为需要的值。</p>

<pre><code>#pragma mark - UIImagePickerControllerDelegate

- (void)imagePickerController:(UIImagePickerController *)picker         didFinishPickingMediaWithInfo:(NSDictionary *)info
{
    [self dismissViewControllerAnimated:YES completion:^{
    [self performSelector:@selector(resetIdleTimerDisabled) withObject:nil          afterDelay:1.0];
     }];
}

- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker
{
  [self dismissViewControllerAnimated:YES completion:^{
  [self performSelector:@selector(resetIdleTimerDisabled) withObject:nil        afterDelay:1.0];
   }];
}
</code></pre>

<p>参考：</p>

<p><a href="http://stackoverflow.com/questions/23391564/ios-idletimerdisabled-yes-works-only-until-imagepicker-was-used">http://stackoverflow.com/questions/23391564/ios-idletimerdisabled-yes-works-only-until-imagepicker-was-used</a></p>

<p><a href="http://www.objc.io/issue-19/">http://www.objc.io/issue-19/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac book升级Yosemite异常的解决方法]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/19/mac-booksheng-ji-yosemiteyi-chang-de-jie-jue-fang-fa/"/>
    <updated>2014-10-19T11:11:55+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/19/mac-booksheng-ji-yosemiteyi-chang-de-jie-jue-fang-fa</id>
    <content type="html"><![CDATA[<p>前天苹果更新新版桌面操作系统OS X Yosemite，版本号为OS X 10.10。兴匆匆地升级我的Mac book，等了好久，更新重启之后出现了下面这个画面：</p>

<p><img src="http://Hydra2050.github.io/images/20141019.jpg" alt="OooppP" /></p>

<p>解决方法很简单：</p>

<ul>
<li>第一步：长按关机键，然后重新启动，同时一直按住<code>alt</code>键</li>
<li>第二步：在出现的界面选择无线网络，并成功连接</li>
<li>第三部：按<code>command</code> ＋ <code>r</code>，进入网络恢复模式</li>
</ul>


<p>经过N久的等待，终于又恢复正常了，开始体验新的OS X —— Yosemite！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge–Level 3]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-3/"/>
    <updated>2014-10-19T10:35:11+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-3</id>
    <content type="html"><![CDATA[<p>Level3地址：<a href="http://www.pythonchallenge.com/pc/def/equality.html">http://www.pythonchallenge.com/pc/def/equality.html</a></p>

<h2>分析</h2>

<p>提示文字：</p>

<pre><code>One small letter, surrounded by EXACTLY three big bodyguards on each of its sides.
</code></pre>

<p>根据上一次的经验，查看网页的源码，标题为<code>re</code>，看来和正则表达式有关系了。</p>

<p>网页源码里仍然有一段被注释的字符串，看来就要在这一串中找出两边大写中间小写字母的内容了。</p>

<h2>解决</h2>

<pre><code>text = ‘’’
       …
       ‘’’
import re
pattern = re.compile(r'[A-Z]{3}([a-z])[A-Z]{3}')
result = re.findall(pattern,text)
print(‘’.join(result))
</code></pre>

<p>发现打印出来很多结果，哪里出了问题？</p>

<p>再仔细看提示语：<code>EXACTLY</code>，必须是有且只有三个大写字母。</p>

<p>修改正则表达式：</p>

<pre><code>pattern = re.compile(r'[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]')
</code></pre>

<p>输出：</p>

<pre><code>linkedlist
</code></pre>

<h2>其他解决方法</h2>

<p><a href="http://www.pythonchallenge.com/pcc/def/linkedlist.php">http://www.pythonchallenge.com/pcc/def/linkedlist.php</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge–Level 2]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-2/"/>
    <updated>2014-10-19T09:15:54+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/19/the-python-challenge-level-2</id>
    <content type="html"><![CDATA[<h2>分析</h2>

<p>Level2的地址：<a href="http://www.pythonchallenge.com/pc/def/ocr.html">http://www.pythonchallenge.com/pc/def/ocr.html</a></p>

<p>文字提示<code>MAYBE they are in the page source</code></p>

<p>查看网页的源码，发现注释的部分：</p>

<pre><code>find rare characters in the mess below:
</code></pre>

<p>需要从那段内容中找出稀少的字符。</p>

<h2>解决</h2>

<pre><code>text = ‘’’
      …
       ‘’’
result = {}
for x in text:
    result[x] = result.get(x,0) + 1
print(result)
</code></pre>

<p>输出：</p>

<pre><code>{'(': 6154, ')': 6186, '*': 6034, '+': 6066, 'l': 1, 'i': 1, ' ': 4880, '!': 6079, '#': 6115, '$': 6046, '%': 6104, '&amp;': 6043, 'e': 1, 'y': 1, '{': 6046, '}': 6105, 'q': 1, 't': 1, 'u': 1, 'a': 1, '\n': 1221, '@': 6157, '[': 6108, ']': 6152, '^': 6030, '_': 6112}
</code></pre>

<p>发现最少的都是个数为1的字母，这样稍加改变：</p>

<pre><code>result = []
for x in text:
    if x.isalpha():
        result.append(x)
print(''.join(result))
</code></pre>

<p>输出：</p>

<pre><code>equality
</code></pre>

<h2>其他的解决方法</h2>

<p>按照惯例，查看解决方法：<a href="http://www.pythonchallenge.com/pcc/def/ocr.html">http://www.pythonchallenge.com/pcc/def/ocr.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge--Level 1]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/11/the-python-challenge-level-1/"/>
    <updated>2014-10-11T21:46:08+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/11/the-python-challenge-level-1</id>
    <content type="html"><![CDATA[<p>Level 1的地址：<a href="http://www.pythonchallenge.com/pc/def/map.html">http://www.pythonchallenge.com/pc/def/map.html</a></p>

<h2>分析</h2>

<p>网页的标题为<code>What about making trans?</code>，然后再看图片：</p>

<pre><code>K -&gt; M
O -&gt; Q
E -&gt; G
</code></pre>

<p>应该是一个类似凯撒密码的字母移位，每个字母向后移动两位，而要处理的就是下面那段文字。</p>

<h2>解决</h2>

<p>代码如下：</p>

<pre><code>'''
Level 1
'''
text = '''
g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr   gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle    qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.
'''
trans = ''
for x in text:
    trans += chr((ord(x) - ord('a') + 2)%26 + ord('a')) if x.isalpha() else x
print(trans)
</code></pre>

<p>输出结果：</p>

<pre><code>i hope you didnt translate it by hand. thats what computers are for. doing it in
by hand is inefficient and that's why this text is so long. using string.maketrans() 
is recommended. now apply on the url.
</code></pre>

<p>根据转化后的信息，处理url中的map进行同样的转换，获得新的url：<a href="http://www.pythonchallenge.com/pc/def/ocr.html">http://www.pythonchallenge.com/pc/def/ocr.html</a>，顺利进入下一关。</p>

<h2>str.maketrans()</h2>

<p>等等，仔细看转换后的信息，推荐使用string.maketrans()方法。</p>

<p>查找<a href="https://docs.python.org/3/">python3在线文档</a>，发现在python3.4后有所变化。</p>

<p>代码如下：</p>

<pre><code>''
use str.maketrans()
'''

import string

text = '''
g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr   gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle    qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.
'''

dlist = string.ascii_lowercase
table = str.maketrans(dlist,dlist[2:] + dlist[:2])
print(text.translate(table))
</code></pre>

<p>首先，使用str.maketrans()方法生成一个映射表，从[A－Z]映射为[C-A]，打印<code>table</code>：</p>

<pre><code>{97: 99, 98: 100, 99: 101, 100: 102, 101: 103, 102: 104, 103: 105, 104: 106, 105: 107, 106: 108, 107: 109, 108: 110, 109: 111, 110: 112, 111: 113, 112: 114, 113: 115, 114: 116, 115: 117, 116: 118, 117: 119, 118: 120, 119: 121, 120: 122, 121: 97, 122: 98}
</code></pre>

<p>然后，调用translate()方法，将映射表作为参数。最终获取想要的结果。</p>

<p><code>str.maketrans()</code>的第一个和第二个参数长度必须相同，转换的时候一一对应；如果有第三个参数，将会转换为<code>None</code>。</p>

<pre><code>mm = 'abcdefg'
tb1 = str.maketrans('abcd','1234')
tb2 = str.maketrans('abcd','1234','ef')
print(mm.translate(tb1))
print(mm.translate(tb2))
</code></pre>

<p>输出结果：</p>

<pre><code>1234efg
1234g
</code></pre>

<h2>其他的解决方法</h2>

<p>进入下一个Level的页面，有一条tips，将当前url中的<code>pc</code>改为<code>pcc</code>就可以查看前一个Level的解决方法了。</p>

<p><a href="http://www.pythonchallenge.com/pcc/def/ocr.html">http://www.pythonchallenge.com/pcc/def/ocr.html</a></p>

<p>参考资料：</p>

<p><a href="https://docs.python.org/3/">Python documentation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Challenge--Level 0]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/10/10/the-python-challenge-level-0/"/>
    <updated>2014-10-10T22:51:40+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/10/10/the-python-challenge-level-0</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>最近空余时间，开始学习python，发现一个很有意思的网站：<a href="http://www.pythonchallenge.com/">pythonchallenge</a>。目前有33个挑战的级别，打算写一个系列的博客，记录下来学习的过程。那就从零开始吧！</p>

<h2>Level 0</h2>

<p>Level 0的地址：<a href="http://www.pythonchallenge.com/pc/def/0.html">http://www.pythonchallenge.com/pc/def/0.html</a></p>

<p>一张图片，上面写着2的38次方</p>

<pre><code>Hint: try to change the URL address.
</code></pre>

<p>使用python求2的38次方的值：</p>

<pre><code>2**38
</code></pre>

<p>或者：</p>

<pre><code>import math
pow(2,38)
</code></pre>

<p>或者：</p>

<pre><code>1 &lt;&lt; 38
</code></pre>

<p>得到结果：274877906944</p>

<p>根据提示，修改url为：<a href="http://www.pythonchallenge.com/pc/def/274877906944.html">http://www.pythonchallenge.com/pc/def/274877906944.html</a>。</p>

<p>这样就进入下一关了， ^_^)</p>

<p>参考资料：</p>

<p><a href="http://sebug.net/paper/books/dive-into-python3/index.html">深入 Python 3</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac上iOS开发抓包的几种常用方法]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/07/26/iosshe-bei-zhua-bao-de-ji-chong-chang-yong-fang-fa/"/>
    <updated>2014-07-26T21:56:07+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/07/26/iosshe-bei-zhua-bao-de-ji-chong-chang-yong-fang-fa</id>
    <content type="html"><![CDATA[<p>在iOS开发中，经常需要抓包来查看网络请求、应答的情况，例如坚持服务端应答数据、服务端应答速度、客户端发生请求、流量检测、安全性检测等等。不论代码内如何实现，抓包能够最好的证实一切，往往可以更快地定位问题，解决问题。下面总结几种常用的抓包方法。</p>

<h2>使用charles抓包</h2>

<p>在mac下，<a href="http://www.charlesproxy.com/">charles</a>是一个非常好用的抓取http/https请求的工具。</p>

<p>限制条件：</p>

<ul>
<li>需要mac与iOS设备连接相同的无线网络</li>
<li>只能抓取http/https的数据包</li>
<li>无法抓取2G/3G/4G网络下得数据</li>
</ul>


<p>［注］：更多关于charles的使用方法参照<a href="http://www.charlesproxy.com/documentation/">http://www.charlesproxy.com/documentation/</a></p>

<h2>使用RVI（Remote Virtual Interface）+wireshark抓包</h2>

<p>在iOS5以后，Apple为iOS引入了RVI（Remote Virtual Interface），只要设备通过USB连接到Mac，就可以虚拟出一个远程端口，这样就可以在Mac上使用Wireshark抓取这个远程虚拟端口的数据包了。</p>

<p>限制条件：</p>

<ul>
<li>支持的设备系统iOS5以及之后</li>
</ul>


<h2>使用tcpdump命令抓包</h2>

<p>限制条件：</p>

<ul>
<li>需要iOS设备越狱</li>
</ul>


<h2>小结</h2>

<p>以上是平时常用到得几种抓包方法，各有优缺点，可以根据需要选择最方便的方法。</p>

<h2>参考资料</h2>

<p><a href="http://www.charlesproxy.com/">http://www.charlesproxy.com/</a></p>

<p><a href="http://www.charlesproxy.com/documentation/">http://www.charlesproxy.com/documentation/</a></p>

<p><a href="http://www.wireshark.org/">http://www.wireshark.org/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用UIMotionEffect实现设备的倾斜视差]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/02/16/shi-yong-uimotioneffect/"/>
    <updated>2014-02-16T18:28:08+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/02/16/shi-yong-uimotioneffect</id>
    <content type="html"><![CDATA[<p>iOS7更新后，当倾斜手机的时候，会看到屏幕上的背景图片会随着手机的倾斜度而移动，产生视差。刚开始更新的时候，还以为是自己的错觉，－－！。</p>

<p>UIMotionEffect就像它的名字一样，处理motion effect。UIMotionEffect是一个抽象的基类，子类通过重写<code>keyPathsAndRelativeValuesForViewerOffset:</code>方法，当检测到动作的时候</p>

<p>苹果提供了一个子类UIInterpolatingMotionEffect，通过它我们可以实现对设备水平和竖直方向倾斜。</p>

<pre><code>UIInterpolatingMotionEffect *horizontalMotionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];
horizontalMotionEffect.minimumRelativeValue = @(-50);
horizontalMotionEffect.maximumRelativeValue = @(50);
[redView addMotionEffect:horizontalMotionEffect];
</code></pre>

<p><a href="http://www.teehanlax.com/blog/introduction-to-uimotioneffect/">http://www.teehanlax.com/blog/introduction-to-uimotioneffect/</a>
<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffect_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013376">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffect_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013376</a>
<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffectGroup_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013378">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMotionEffectGroup_class/Reference/Reference.html#//apple_ref/doc/uid/TP40013378</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用NSLog打印CGPoint、CGSize、CGRect]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/18/use-nslog-to-print-cgpoint-cgrect/"/>
    <updated>2014-01-18T22:02:46+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/18/use-nslog-to-print-cgpoint-cgrect</id>
    <content type="html"><![CDATA[<p>平时调试程序的时候，经常会使用NSLog打印出来。当有CGPoint、CGSize、CGRect对象要打印时，一般要写成下面的方式：</p>

<pre><code>CGPoint point = CGPointMake(0, 20);
NSLog(@"Point: x=%f, y=%f", point.x, point.y);

CGSize size = CGSizeMake(200, 100);
NSLog(@"Size: w=%f, h=%f", size.width, size.height);

CGRect rect = CGRectMake(0, 0, 200, 100);
NSLog(@"Rect: x=%f, y=%f, w=%f, h=%f", rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
</code></pre>

<p>今天看到一篇文章：<a href="http://iosdevelopertips.com/debugging/how-to-use-nslog-to-debug-cgrect-and-cgpoint.html">How to Use NSLog to Debug CGRect and CGPoint</a>，才了解到有一些其他方便的方法。</p>

<pre><code>CGPoint point = CGPointMake(0, 20);
NSLog(@"Point: %@", NSStringFromCGPoint(point));

CGSize size = CGSizeMake(200, 100);
NSLog(@"Size: %@", NSStringFromCGSize(size));

CGRect rect = CGRectMake(0, 0, 200, 100);
NSLog(@"Rect: %@", NSStringFromCGRect(rect));
</code></pre>

<p>打印结果：</p>

<pre><code>Point: {0, 20}
Size: {200, 100}
Rect: \{\{0, 0\}, \{200, 100\}\}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发中一些常用的宏定义]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/18/ioskai-fa-zhong-%5B%3F%5D-xie-chang-yong-de-hong-ding-yi/"/>
    <updated>2014-01-18T21:55:51+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/18/ioskai-fa-zhong-[?]-xie-chang-yong-de-hong-ding-yi</id>
    <content type="html"><![CDATA[<p>Debug输出：</p>

<pre><code>#ifdef DEBUG
    #define debug(format, ...) CFShow([NSString stringWithFormat:format, ## __VA_ARGS__]);
    #define debugAlert(format, ...)  {UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@"%s\n line: %d ", __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:format, ##__VA_ARGS__]  delegate:nil cancelButtonTitle:@"Done" otherButtonTitles:nil]; [alert show]; [alert release];}
#else
    #define debug(format, ...) 
    #define debugAlert(format, ...)
#endif
</code></pre>

<p>检测是否支持ARC：</p>

<pre><code>#if __has_feature(objc_arc)
    // ARC
#else
    // No ARC
#endif
</code></pre>

<p><a href="http://iosdevelopertips.com/debugging/remove-debug-code-for-release-build.html">http://iosdevelopertips.com/debugging/remove-debug-code-for-release-build.html</a></p>

<p><a href="http://iosdevelopertips.com/debugging/display-debug-information-in-uialertview.html">http://iosdevelopertips.com/debugging/display-debug-information-in-uialertview.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Properties to a Category Using Associated Objects]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/16/adding-properties-to-a-category-using-associated-objects/"/>
    <updated>2014-01-16T22:39:50+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/16/adding-properties-to-a-category-using-associated-objects</id>
    <content type="html"><![CDATA[<h2>Object-C中的Category</h2>

<p>Object-C中的Category，相信大家一定不会陌生。一般来说，我们可以用它来为一个类添加新的方法：</p>

<pre><code>@interface NSString (NumberUtils)
- (BOOL)isNumeric; 
@end

@implementation NSString (NumberUtils) 
- (BOOL)isNumeric
{
    NSScanner *scanner = [NSScanner scannerWithString:self];
    return [scanner scanFloat:NULL]? [scanner isAtEnd]: NO;
}
@end
</code></pre>

<p>我们也可以Category中定义新的数据成员，但是不能够对它们使用synthesize。这是因为一个类的结构已经在编译器决定了，而Category是在运行期定义生成的，这样就没有办法改变类结构体中的ivars。</p>

<pre><code>struct objc_class {  
    Class isa  OBJC_ISA_AVAILABILITY;  

    #if !__OBJC2__  
    Class super_class                                        OBJC2_UNAVAILABLE;  
    const charchar *name                                     OBJC2_UNAVAILABLE;  
    long version                                             OBJC2_UNAVAILABLE;  
    long info                                                OBJC2_UNAVAILABLE;  
    long instance_size                                       OBJC2_UNAVAILABLE;  
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;  
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;  
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;  
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;  
#endif  

} OBJC2_UNAVAILABLE;    
</code></pre>

<p>可以向下面这样定义：</p>

<pre><code>@interface NSString (NumberUtils)
@property (nonatomic, readonly, getter=isNumeric) BOOL numeric;
@end
</code></pre>

<p>如果我们想为一个类真正添加一个数据成员，要怎么办呢？当然你可能会想到使用修饰者，封装出一个对象，包含这个类和想要添加的数据成员。但是那样要麻烦一些。</p>

<h2>使用Associated Objects为一个分类添加数据成员</h2>

<p>使用Runtime来解决这个问题。要使用的API：</p>

<pre><code> // 使用一个key值和关联策略来为一个对象设置一个关联的值
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
</code></pre>

<p><code>objc_setAssociatedObject</code>：使用一个key值和关联策略来为一个对象设置一个关联的值。类似NSDictionry，一个key值，对应一个value值。</p>

<p>key值必须是进程的生命周期内一个唯一、不变的id值。可以使用一个NSString对象作为一个key值。但是如果试图通过一个相同的字符串值，但是不同内存地址作为key值，可能不会获得预期的结果。一个更好的选择是定义一个static的指针作为key值。</p>

<p>下面一个例子：</p>

<pre><code>@interface UIImage (Tagged)
@property (nonatomic, copy) NSString *tag;
@end    

#import &lt;objc/runtime.h&gt; 

static const void *ImageTagKey = &amp;ImageTagKey;
@implementation UIImage (Tagged)

- (void)setTag:(NSSting *)tag
{
    objc_setAssociatedObject(self, ImageTagKey, tag, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (NSString *)tag
{
    return objc_getAssociatedObject(self, ImageTagKey);
}
@end
</code></pre>

<p>这个例子中有一点点需要主要：</p>

<ul>
<li>key值使用一个指针类型static const void * 。我们必须让这个指针初始化，否则它的值就会为NULL，但是我们不关心具体指向什么，只要它是唯一的，不变的。这里面，指针指向了自己，一个唯一、不变的值。</li>
</ul>


<p>参考文章：</p>

<p><a href="https://developer.apple.com/library/ios/documentation/cocoa/reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/constant_group/Associative_Object_Behaviors">Objective-C Runtime Reference</a></p>

<p><a href="http://iosdevelopertips.com/objective-c/adding-properties-category-using-associated-objects.html">Adding Properties to a Category Using Associated Objects</a></p>

<p><a href="http://nshipster.com/associated-objects/">Associated Objects</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa简介]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/12/reactivecocoajian-jie/"/>
    <updated>2014-01-12T22:40:40+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/12/reactivecocoajian-jie</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年读过的好书]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/12/2013nian-du-guo-de-hao-shu/"/>
    <updated>2014-01-12T16:45:59+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/12/2013nian-du-guo-de-hao-shu</id>
    <content type="html"><![CDATA[<h2>技术类书籍</h2>

<p>首先时技术类书籍：</p>

<ul>
<li>《从小工到专家——程序员修炼之道》</li>
<li>《Head First 设计模式》</li>
<li>《iOS 高级编程》</li>
<li>《Python》</li>
</ul>


<h2>非技术类书籍</h2>

<p>非技术类：</p>

<ul>
<li>《一个人的村庄》</li>
<li>《1984》</li>
<li>《少有人走的路》</li>
<li>《自由在高处》</li>
<li>《九种孤独》</li>
<li>《天才在左，疯子在右》</li>
<li>《猎命师传奇：卷二十》</li>
<li>《上帝掷骰子吗》</li>
<li>《沉默的大多数》</li>
<li>《变身》、《新参者》</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP的缓存机制]]></title>
    <link href="http://Hydra2050.github.io/blog/2014/01/12/http-cache/"/>
    <updated>2014-01-12T13:56:24+08:00</updated>
    <id>http://Hydra2050.github.io/blog/2014/01/12/http-cache</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>HTTP的缓存机制，主要体现在HTTP协议头里面的几个字段——Expires、Cache-control、Last-Modified/If-Modified-Since、Etag/If-None-Match等。在移动开发中，了解HTTP的缓存对开发者来说已经必不可少。</p>

<p><img src="http://Hydra2050.github.io/images/2014011216.png" alt="HTTP HEAD" /></p>

<h2>Expires</h2>

<p>HTTP头中的Expires字段，告诉浏览器在Expires显示的时间前，浏览器可以从缓存中读取，而不需要再次去请求。</p>

<h2>Cache-control</h2>

<p>Cache-control与Expires一样，都是告诉浏览器有效期。不过它不只是设置过期时间，还可以设置很多选项：</p>

<ul>
<li>no-cache指示请求或响应消息不能缓存</li>
<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>
<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>
<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>
<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>
</ul>


<p>如上图：max-age＝600，表示600s内不需要重新请求。</p>

<h2>Last-Modified</h2>

<p><code>Last-Modified</code>：资源的最后修改时间。</p>

<p>如果本地缓存已经过期，即超过了<code>max-age</code>的缓存时间，缓存的HTTP头中存在Last-Modified，则向服务器发送带有If-Modified-Since字段的请求，后面带上<code>Last-Modified</code>所记录的最后修改时间。</p>

<p>服务器收到带有<code>If-Modified-Since</code>的HTTP请求，会将请求的资源修改时间与<code>If-Modified-Since</code>时间对比：如果这段时间没有被修改过，则返回304，告诉浏览器可以继续使用本地缓存；如果资源已经修改过了，则响应请求的资源数据，返回200 OK.</p>

<h2>Etag</h2>

<p><code>Etag</code>：服务器应答数据的时候，生成的当前资源的唯一标识。</p>

<p>如果本地缓存已经过期，即超过了<code>max-age</code>的缓存时间，缓存的HTTP头中存在<code>Etag</code>，则向服务器发送带有<code>If-None-Match</code>字段的请求，后面带上<code>Etag</code>所记录的当前资源的唯一标识。</p>

<p>服务器收到带有<code>If-None-Match</code>的HTTP请求，会将请求的资源唯一标识与<code>If-None-Match</code>的标签的标识对比：如果这段时间没有被修改过，则返回304，告诉浏览器可以继续使用本地缓存；如果资源已经修改过了，则响应请求的资源数据，返回200 OK。</p>

<h2>Etag与Last-Modified的区别？</h2>

<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>

<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>


<p><code>Etag</code>是服务器生成的对应资源的唯一标识符，能够更加准确的控制缓存。<code>Last-Modified</code>与<code>ETag</code>是可以一起使用的，服务器会优先验证<code>ETag</code>，一致的情况下，才会继续比对<code>Last-Modified</code>。</p>

<h2>跳转、刷新、强制刷新</h2>

<p>浏览器缓存行为还有用户的行为有关:</p>

<table>
<thead>
<tr>
<th>用户操作      </th>
<th align="center"> Expires/Cache-control </th>
<th align="center"> Last-Moified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址栏回车     </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>页面链接跳转   </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效  </td>
</tr>
<tr>
<td>新开窗口      </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>前进、后退     </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效 </td>
</tr>
<tr>
<td>F5刷新        </td>
<td align="center"> 无效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>Ctrl＋F5刷新  </td>
<td align="center"> 无效                  </td>
<td align="center"> 无效 </td>
</tr>
</tbody>
</table>


<h2>总结</h2>

<p>当本地存在缓存的时候，一次请求的流程：</p>

<p><img src="http://Hydra2050.github.io/images/HTTPCache.png" alt="HTTP Cache" /></p>

<p>参考：<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">Cache-Control section of RFC 2616</a></p>
]]></content>
  </entry>
  
</feed>
