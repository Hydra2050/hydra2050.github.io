
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>王仙客的博客</title>
	<meta name="author" content="王仙客">

	
	<meta name="description" content="Jan 18th, 2014 如何使用NSLog打印CGPoint、CGSize、CGRect 平时调试程序的时候，经常会使用NSLog打印出来。当有CGPoint、CGSize、CGRect对象要打印时，一般要写成下面的方式： CGPoint point = CGPointMake(0, 20 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="王仙客的博客" type="application/atom+xml">
	
	<link rel="canonical" href="http://Hydra2050.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("wh2050@sina.cn") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
	<p style="color:white;font-size:24px">王仙客的博客</p>
	<br>
	<p style="color:white;font-size:18px">明白一些道理</p>
	<p style="color:white;font-size:18px">遇到一些有趣的事</p>
	<br>
	<li><a href="/">博客</a></li>
	<li><a href="/blog/archives">所有文章</a></li>
	<li><a href="/blog/2013/12/04/about/">关于我</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:wh2050@sina.cn" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-18T22:02:46+08:00" data-updated="true" itemprop="datePublished">Jan 18<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/18/use-nslog-to-print-cgpoint-cgrect/" itemprop="url">如何使用NSLog打印CGPoint、CGSize、CGRect</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>平时调试程序的时候，经常会使用NSLog打印出来。当有CGPoint、CGSize、CGRect对象要打印时，一般要写成下面的方式：</p>

<pre><code>CGPoint point = CGPointMake(0, 20);
NSLog(@"Point: x=%f, y=%f", point.x, point.y);

CGSize size = CGSizeMake(200, 100);
NSLog(@"Size: w=%f, h=%f", size.width, size.height);

CGRect rect = CGRectMake(0, 0, 200, 100);
NSLog(@"Rect: x=%f, y=%f, w=%f, h=%f", rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
</code></pre>

<p>今天看到一篇文章：<a href="http://iosdevelopertips.com/debugging/how-to-use-nslog-to-debug-cgrect-and-cgpoint.html">How to Use NSLog to Debug CGRect and CGPoint</a>，才了解到有一些其他方便的方法。</p>

<pre><code>CGPoint point = CGPointMake(0, 20);
NSLog(@"Point: %@", NSStringFromCGPoint(point));

CGSize size = CGSizeMake(200, 100);
NSLog(@"Size: %@", NSStringFromCGSize(size));

CGRect rect = CGRectMake(0, 0, 200, 100);
NSLog(@"Rect: %@", NSStringFromCGRect(rect));
</code></pre>

<p>打印结果：</p>

<pre><code>Point: {0, 20}
Size: {200, 100}
Rect: \{\{0, 0\}, \{200, 100\}\}
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-18T21:55:51+08:00" data-updated="true" itemprop="datePublished">Jan 18<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/18/ioskai-fa-zhong-%5B%3F%5D-xie-chang-yong-de-hong-ding-yi/" itemprop="url">iOS开发中一些常用的宏定义</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Debug输出：</p>

<pre><code>#ifdef DEBUG
    #define debug(format, ...) CFShow([NSString stringWithFormat:format, ## __VA_ARGS__]);
    #define debugAlert(format, ...)  {UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@"%s\n line: %d ", __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:format, ##__VA_ARGS__]  delegate:nil cancelButtonTitle:@"Done" otherButtonTitles:nil]; [alert show]; [alert release];}
#else
    #define debug(format, ...) 
    #define debugAlert(format, ...)
#endif
</code></pre>

<p>检测是否支持ARC：</p>

<pre><code>#if __has_feature(objc_arc)
    // ARC
#else
    // No ARC
#endif
</code></pre>

<p><a href="http://iosdevelopertips.com/debugging/remove-debug-code-for-release-build.html">http://iosdevelopertips.com/debugging/remove-debug-code-for-release-build.html</a></p>

<p><a href="http://iosdevelopertips.com/debugging/display-debug-information-in-uialertview.html">http://iosdevelopertips.com/debugging/display-debug-information-in-uialertview.html</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-16T22:39:50+08:00" data-updated="true" itemprop="datePublished">Jan 16<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/16/adding-properties-to-a-category-using-associated-objects/" itemprop="url">Adding Properties to a Category Using Associated Objects</a></h1>
	<div class="entry-content" itemprop="articleBody">
		

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-12T22:41:13+08:00" data-updated="true" itemprop="datePublished">Jan 12<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/12/object-czhong-de-na-xie-hei-mo-fa/" itemprop="url">Object-C中的那些黑魔法</a></h1>
	<div class="entry-content" itemprop="articleBody">
		

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-12T22:40:40+08:00" data-updated="true" itemprop="datePublished">Jan 12<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/12/reactivecocoajian-jie/" itemprop="url">ReactiveCocoa简介</a></h1>
	<div class="entry-content" itemprop="articleBody">
		

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-12T16:45:59+08:00" data-updated="true" itemprop="datePublished">Jan 12<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/12/2013nian-du-guo-de-hao-shu/" itemprop="url">2013年读过的好书</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>技术类书籍</h2>

<p>首先时技术类书籍：</p>

<ul>
<li>《从小工到专家——程序员修炼之道》：</li>
<li>《Head First 设计模式》：</li>
<li>《iOS 高级编程》：</li>
<li>《Python》：</li>
<li>《STL源码剖析》：</li>
</ul>


<h2>非技术类书籍</h2>

<p>非技术类：</p>

<ul>
<li>《一个人的村庄》：</li>
<li>《1984》：</li>
<li>《少有人走的路：》：</li>
<li>《自由在高处》：</li>
<li>《九种孤独》：</li>
<li>《天才在左，疯子在右》：</li>
<li>《猎命师传奇：卷二十》：</li>
<li>《上帝掷骰子吗》：</li>
<li>《沉默的大多数》：</li>
<li>《变身》、《新参者》：</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-12T13:56:24+08:00" data-updated="true" itemprop="datePublished">Jan 12<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/12/http-cache/" itemprop="url">HTTP的缓存机制</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>前言</h2>

<p>HTTP的缓存机制，主要体现在HTTP协议头里面的几个字段——Expires、Cache-control、Last-Modified/If-Modified-Since、Etag/If-None-Match等。在移动开发中，了解HTTP的缓存对开发者来说已经必不可少。</p>

<p><img src="/images/2014011216.png" alt="HTTP HEAD" /></p>

<h2>Expires</h2>

<p>HTTP头中的Expires字段，告诉浏览器在Expires显示的时间前，浏览器可以从缓存中读取，而不需要再次去请求。</p>

<h2>Cache-control</h2>

<p>Cache-control与Expires一样，都是告诉浏览器有效期。不过它不只是设置过期时间，还可以设置很多选项：</p>

<ul>
<li>no-cache指示请求或响应消息不能缓存</li>
<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>
<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>
<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>
<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>
</ul>


<p>如上图：max-age＝600，表示600s内不需要重新请求。</p>

<h2>Last-Modified</h2>

<p><code>Last-Modified</code>：资源的最后修改时间。</p>

<p>如果本地缓存已经过期，即超过了<code>max-age</code>的缓存时间，缓存的HTTP头中存在Last-Modified，则向服务器发送带有If-Modified-Since字段的请求，后面带上<code>Last-Modified</code>所记录的最后修改时间。</p>

<p>服务器收到带有<code>If-Modified-Since</code>的HTTP请求，会将请求的资源修改时间与<code>If-Modified-Since</code>时间对比：如果这段时间没有被修改过，则返回304，告诉浏览器可以继续使用本地缓存；如果资源已经修改过了，则响应请求的资源数据，返回200 OK.</p>

<h2>Etag</h2>

<p><code>Etag</code>：服务器应答数据的时候，生成的当前资源的唯一标识。</p>

<p>如果本地缓存已经过期，即超过了<code>max-age</code>的缓存时间，缓存的HTTP头中存在<code>Etag</code>，则向服务器发送带有<code>If-None-Match</code>字段的请求，后面带上<code>Etag</code>所记录的当前资源的唯一标识。</p>

<p>服务器收到带有<code>If-None-Match</code>的HTTP请求，会将请求的资源唯一标识与<code>If-None-Match</code>的标签的标识对比：如果这段时间没有被修改过，则返回304，告诉浏览器可以继续使用本地缓存；如果资源已经修改过了，则响应请求的资源数据，返回200 OK。</p>

<h2>Etag与Last-Modified的区别？</h2>

<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>

<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>


<p><code>Etag</code>是服务器生成的对应资源的唯一标识符，能够更加准确的控制缓存。<code>Last-Modified</code>与<code>ETag</code>是可以一起使用的，服务器会优先验证<code>ETag</code>，一致的情况下，才会继续比对<code>Last-Modified</code>。</p>

<h2>跳转、刷新、强制刷新</h2>

<p>浏览器缓存行为还有用户的行为有关:</p>

<table>
<thead>
<tr>
<th>用户操作      </th>
<th align="center"> Expires/Cache-control </th>
<th align="center"> Last-Moified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址栏回车     </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>页面链接跳转   </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效  </td>
</tr>
<tr>
<td>新开窗口      </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>前进、后退     </td>
<td align="center"> 有效                  </td>
<td align="center"> 有效 </td>
</tr>
<tr>
<td>F5刷新        </td>
<td align="center"> 无效                  </td>
<td align="center"> 有效</td>
</tr>
<tr>
<td>Ctrl＋F5刷新  </td>
<td align="center"> 无效                  </td>
<td align="center"> 无效 </td>
</tr>
</tbody>
</table>


<h2>总结</h2>

<p>当本地存在缓存的时候，一次请求的流程：</p>

<p><img src="/images/HTTPCache.png" alt="HTTP Cache" /></p>

<p>参考：<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">Cache-Control section of RFC 2616</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-12-29T18:56:57+08:00" data-updated="true" itemprop="datePublished">Dec 29<span>th</span>, 2013</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/12/29/object-cgao-ji-bian-cheng-xue-xi-san/" itemprop="url">Object-C高级编程学习笔记(三)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-12-22T20:48:19+08:00" data-updated="true" itemprop="datePublished">Dec 22<span>nd</span>, 2013</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/12/22/object-cgao-ji-bian-cheng-xue-xi-2/" itemprop="url">Object-C高级编程学习笔记(二)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>Blocks</h1>

<h2>What is blocks</h2>

<h3>Block语法</h3>

<p>Blocks是C语言的扩充功能：带有自动变量（局部变量）的匿名函数。</p>

<p><code>^</code> <code>返回值类型</code> <code>参数列表</code> <code>表达式</code></p>

<pre><code>^int (int count) {return count + 1;}
</code></pre>

<p>Block语法可以省略几个项目。首先是返回值类型：</p>

<pre><code>^(int count) {return count + 1;}
</code></pre>

<p>其次，如果不使用参数，参数列表可以省略：</p>

<pre><code>^{ print(“Block\n”);}
</code></pre>

<p>使用Block语法讲Block赋值为Block类型变量：</p>

<pre><code>int(^blk) (int) = ^(int count) {return count + 1;}
int(^blk1) (int) = blk;
</code></pre>

<p>使用typedef定义：</p>

<pre><code>typedef int (^blk_t) (int);
blk_t blk = ^(int count) {return count + 1;}
int nResult = blk(10);
</code></pre>

<p>Block类型变量可以像C语言中其他类型变量一样使用。</p>

<h3>截获自动变量值</h3>

<p>Blocks中，Block表达式截获所使用的自动变量的值。因为Block表达式保存了自动变量的值，所以在执行Block语法后，即使改写Block中使用的自动变量的值也不会影响Block执行时自动变量的值。</p>

<pre><code>int a = 10;
int b = 10;
int (^blk) (void) = ^(return a + b;);
b = 2;
blk();
</code></pre>

<p>执行结果为：<code>20</code></p>

<h3>__block说明符</h3>

<p>若想在Block语法的表达式中将值赋给Block语法外的自动变量，需要在自动变量附加<strong>block说明符，该变量成为</strong>block变量。</p>

<pre><code>__block int val = 0;
void(^blk) (void) = ^{val = 1;};
blk();
printf("%d",val);
</code></pre>

<p>执行结果为： <code>1</code></p>

<p>赋值给截获的自动变量会产生编译错误：</p>

<pre><code>id array = [[NSMutableArray alloc] init];
void (^blk) {array = [[NSMutableArray alloc] init]};
</code></pre>

<p>会出现编译错误。</p>

<p>另外，在使用C语言数组时，必须小心使用起指针。</p>

<pre><code>const char text[] = "Hello";
void (^blk) (void) = ^{
    printf("%c\n",text[2]);
};
</code></pre>

<p>在现在的Block中，截获自动变量的方法并没有实现对C语言数组的截获，因此会编译出错。可以使用指针解决：</p>

<pre><code>const char *text = "Hello";
void (^blk) (void) = ^{
    printf("%c\n",text[2]);
};  
</code></pre>

<h2>Blocks的实现</h2>

<p>// TODO:需要一些时间理解</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-12-22T14:28:55+08:00" data-updated="true" itemprop="datePublished">Dec 22<span>nd</span>, 2013</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/12/22/object-cgao-ji-bian-cheng/" itemprop="url">Object-C高级编程学习笔记(一)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>书名：《Object-C高级编程 IOS与OS X多线程和内存管理》</p>

<h2>ARC</h2>

<p>在Object-C中采用Automatic Reference Counting(ARC)机制，让编译器来进行内存管理。</p>

<ol>
<li>使用Xcode4.2或以上版本</li>
<li>使用LLVM编译器3.0或以上版本</li>
<li>编译器选项中设置ARC为有效</li>
</ol>


<h3>所有权修饰符</h3>

<ul>
<li>__strong修饰符</li>
<li>__weak修饰符</li>
<li>__unsafe_unretained修饰符</li>
<li>__autoreleasing修饰符</li>
</ul>


<h4>1. __strong修饰符</h4>

<p>__strong修饰符为id类型和对象类型默认的所有权修饰符,可以省略。</p>

<pre><code>id __strong obj = [[NSObject alloc] init];
</code></pre>

<h4>2. __weak修饰符</h4>

<p>如果只用__strong修饰符，自动引用计数式内容管理必然会发生“循环引用”的问题。</p>

<p>__weak提供弱引用，弱引用不能持有对象实例，可以解决“循环引用”的问题。</p>

<p>下面这段代码：</p>

<pre><code>id __weak obj = [[NSObject alloc] init];
NSLog(@"%@",obj);
</code></pre>

<p>会输出 nil 。因为__weak修饰的obj持用弱引用，在赋值过后，并没有对象强引用它，生成的对象会立即释放。这样obj自动赋值为nil。</p>

<p>再来看看下面这段代码的输出：</p>

<pre><code>id __weak obj0 = nil;
{
    id __strong obj1 = [[NSObject alloc] init];
    obj0 = obj1;
    NSLog(@"%@",obj0);
}
NSLog(@"%@",obj0);
</code></pre>

<p>结果：</p>

<pre><code>&lt;NSObject: 0x109420000&gt;
nil
</code></pre>

<p>注：<strong>weak修饰符只能用于IOS5以上以及OS X Lion以上版本的应用程序。在它们一下的程序可使用</strong>unsafe_unretained修饰符来代替。</p>

<h4>3. __unsafe_unretained修饰符</h4>

<p><strong>unsafe_unretained修饰符，是不安全的所有权修饰符。有</strong>unsafe_unretained修饰符的变量不属于编译器的内存管理对象。</p>

<pre><code>id __unsafe_unretained obj = [[NSObject alloc] init];
NSLog(@"%@",obj);
</code></pre>

<p>这里和__weak一样，会输出<code>nil</code>。难道这两个修饰符相同吗？再来看第二个例子：</p>

<pre><code>id __unsafe_unretained obj0 = nil;
{
    id __strong obj1 = [[NSObject alloc] init];
    obj0 = obj1;
    NSLog(@"%@",obj0);
}
NSLog(@"%@",obj0);
</code></pre>

<p>输出：</p>

<pre><code>&lt;NSObject: 0x10972ced0&gt;
&lt;NSObject: 0x10972ced0&gt;
</code></pre>

<p>可以看到结果已经和__weak不同。</p>

<p>这里在第二次打印的时候，obj0已经成为一个野指针。</p>

<p><strong>weak与</strong>unsafe_unretained的区别可以简单地说：</p>

<p>当弱引用的对象被释放，<strong>weak修饰的对象会自动赋值为nil；而</strong>unsafe_unretained修饰的对象不会。</p>

<h4>4. __autoreleasing修饰符</h4>

<p>在ARC有效的时候，不能使用NSAutoreleasePool。为了实现想非ARC工程的NSAutoreleasePool该怎么办？使用__autoreleasing修饰符。</p>

<p>一下两段代码效果相同：</p>

<pre><code>/* NO ARC */
NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];
[pool drain];

/*  ARC  */
@autoreleasepool {
    id __autoreleasing obj = [[NSObject alloc] init];
}
</code></pre>

<p>但是，显式地附加<strong>autoreleasing修饰符同显式地附加</strong>strong一样罕见。一般不必显示地添加__autoreleasing修饰符。</p>

<p style="color:red"> 另外，无论ARC是否有效，调试用的私有方法_objc_autoreleasePoolPrint()都可以使用。利用这个函数可以有效地帮助我们调试注册到autoreleasepool上的对象。 </p>


<h3>ARC的规则</h3>

<p>1. 不能使用retain/release/retainCount/autorelease</p>

<p>2. 不能使用NSAllocateObject/NSDeallocateObject</p>

<p>3. 遵守内存管理的方法命名规则</p>

<p>4. 不要显示调用dealloc</p>

<p>5. 使用@autoreleasepool快代替NSAutoreleasePool</p>

<p>6. 不能使用NSZone</p>

<p>7. 对象型变量不能作为C语言结构体的成员</p>

<p>要把对象型变量加入到结构体成员，可强制转换为void* 或是添加<code>__unsafe_unretained</code>修饰符。</p>

<h4>显示转换id 和 void*</h4>

<p>下面这段代码，在ARC下会编译错误：</p>

<pre><code>id obj = [[NSObject alloc] init];
void* p = obj;
</code></pre>

<p>需要使用“__bridge转换”：</p>

<p>1、 __bridge</p>

<pre><code>/* ARC */
id obj1 = [[NSObject alloc] init];
void* p = (__bridge void*)obj1;
</code></pre>

<p>相当于：</p>

<pre><code>/* NO ARC */
id obj = [[NSObject alloc] init];
void* p = obj;
</code></pre>

<p>但是使用<strong>bridge转换，其安全性与赋值</strong>unsafe_unretained修饰符相似，甚至更低。</p>

<p>2、 __bridge_retained</p>

<pre><code>/* ARC */
id obj1 = [[NSObject alloc] init];
void* p = (__bridge_retained void*)obj1;
</code></pre>

<p>相当于：</p>

<pre><code>/* NO ARC */
id obj1 = [[NSObject alloc] init];
void* p = obj1;
[(id)p retain];
</code></pre>

<p>下面的代码：</p>

<pre><code>void* p = 0;
{
    id obj1 = [[NSObject alloc] init];
    void* p = (__bridge_retained void*)obj1;
}
NSLog(@"%@",p);
</code></pre>

<p>由于使用__bridge_retained，p在对后持有该对象，所以会打印出该对象。</p>

<p>3、 __bridge_transfer</p>

<pre><code>/* ARC */
id obj1 = [[NSObject alloc] init];
void* p = (__bridge_transfer void*)obj1;
</code></pre>

<p>相当于：</p>

<pre><code>id obj1 = [[NSObject alloc] init];
void* p = obj1;
[(id)p retain];
[obj1 release];
</code></pre>

<p>当然可是实现双向的转换。这些转换多数使用在Objec-C对象和Core Foundation对象之间的互相转换。</p>

<p>以下两个函数为系统提供的方法，实现Toll-Free Bridging：</p>

<pre><code>NS_INLINE id CFBridgingRelease(CFTypeRef CF_CONSUMED X) {
return (__bridge_transfer id)X;
}
NS_INLINE CF_RETURNS_RETAINED CFTypeRef CFBridgingRetain(id X) {
return (__bridge_retained CFTypeRef)X;
}
</code></pre>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">Toll-Free Bridging</a></p>

<h3>属性</h3>

<p>ARC中，属性声明的属性与所有权修饰符的关系</p>

<table>
<thead>
<tr>
<th align="center">   属性声明   </th>
<th align="center"> 所有权修饰符           </th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">assign           </td>
<td align="center"> __unsafe_unretained  </td>
</tr>
<tr>
<td align="center">copy             </td>
<td align="center"> __strong(复制对象)    </td>
</tr>
<tr>
<td align="center">retain           </td>
<td align="center"> __strong             </td>
</tr>
<tr>
<td align="center">strong           </td>
<td align="center"> __strong             </td>
</tr>
<tr>
<td align="center">unsafe_unretained</td>
<td align="center"> __unsafe_unretained </td>
</tr>
<tr>
<td align="center">weak             </td>
<td align="center"> __weak               </td>
</tr>
</tbody>
</table>


<p style="color:red">有一种情况不能使用__weak修饰符：</p>


<p></p>

<pre><code>- (BOOL)allowsWeakReference UNAVAILABLE_ATTRIBUTE;
- (BOOL)retainWeakReference UNAVAILABLE_ATTRIBUTE;
</code></pre>

<p>如果NSobject实例上面的两个方法返回NO，绝对不能使用__weak修饰符。</p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    王仙客


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






		</div>
	</div>
</body>
</html>
